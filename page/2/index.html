<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http:&#x2F;&#x2F;huwj.work&#x2F;page&#x2F;2&#x2F;index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://huwj.work"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-多线程0" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B0" class="article-date">
  <time datetime="2018-10-12T01:47:48.000Z" itemprop="datePublished">2018-10-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B0">Thread跟Runnable</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Thread与Runable区别："><a href="#Thread与Runable区别：" class="headerlink" title="Thread与Runable区别："></a>Thread与Runable区别：</h2><p>1将线程的任务从线程的子类中分离出来，进行了单独的封装，按照面向对象的思想将任务封装成对象</p>
<p>2避免了java单继承的局限性</p>
<p>3Thread其实相当于new了多个对象对run（）进行操作，故其中的代码，成员属性等都是所属于每一个对象，故数据不是共享的。考虑static<br><img src="/images/java/Thread/3.png" alt="Alt text"><br>对上图进行说明一下:</p>
<p>在Thread中,由于直接是new了3个MyThread对象,故会产生3个堆内存,每个都有自己的things,也有自己的run();故每个run（）都会输出自己的thing。而Runnable中，只进行了一次的new对象，故在对内存中产生一个thing，只不过，new了3个run方法，这三个方法只会对一个对内存中的thing进行计算，同时应该知道，在Runnable中，是按照面向对象的思想将任务封装成对象，也就是在</p>
<pre><code>MyRunnable run =new MyRunnable（）
 将run（任务）放到在线程中（封装成对象）/参考毕向东的13章11节</code></pre><p>Thread也是Runnable接口的子类，但其没有完全实现run()方法，所以说如果继承Thread类实现多线程，仍旧需要覆写run()方法。</p>
<p>综上，所以一般直接使用Runnable<br><img src="/images/java/Thread/0.png" alt="Alt text"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://huwj.work/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B0" data-id="ck3gl3nu3001pvkezetk28pag" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-职场" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/%E7%82%B9%E6%BB%B4%E7%94%9F%E6%B4%BB/%E8%81%8C%E5%9C%BA" class="article-date">
  <time datetime="2018-10-10T13:24:27.000Z" itemprop="datePublished">2018-10-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%82%B9%E6%BB%B4%E7%94%9F%E6%B4%BB/">点滴生活</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/%E7%82%B9%E6%BB%B4%E7%94%9F%E6%B4%BB/%E8%81%8C%E5%9C%BA">职场</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、有”同理心”"><a href="#一、有”同理心”" class="headerlink" title="一、有”同理心”"></a>一、有”同理心”</h2><h3 id="1-1、什么叫”同理心”"><a href="#1-1、什么叫”同理心”" class="headerlink" title="1.1、什么叫”同理心”?"></a>1.1、什么叫”同理心”?</h3><p>　　说复杂点儿，同理心就是站在当事人的角度和位置上，客观地理解当事人的内心感受，且把这种理解传达给当事人的一种沟通交流方式。</p>
<p>　　说简单点儿，同理心就是“己所不欲，勿施于人”。将心比心，也就是设身处地去感受、去体谅他人。</p>
<p>　　说白了，同理心就是“情商”。</p>
<p>　　具体点说：</p>
<p>　　同理心就是，领导交办一项工作，你要读懂他的目的、看清他的用意。我经常遇到这样的情况：给团队成员安排工作时，一再询问“我说明白了吗”“有 没有问题”，再三确认后，提交上来的东西仍然答非所问。所以我在接受任务时，总会向领导确认：你想要的是什么?你的目的是什么?了解这个以后，就可以站在 他的角度，有效的帮他解决问题。</p>
<p>　　同理心就是，在激励员工时，点准他们的“兴奋点”，不揭“伤疤”。每个人都有认真工作的理由，家庭富裕的为了证明自己的能力，家境贫寒的为了改 善自己的生活，吊儿郎当的爱面子怕丢工作。了解不同人的不同心理需求，才能调动大家的积极性。若是不问青红皂白，拿着鞭子大喊加油，只能是徒劳无功。</p>
<p>　　同理心就是，在与他人合作时，了解对方的需求和心理，潜移默化的说服对方，双方为了同一个目标而努力。想用强势压服别人，通常不好使。</p>
<h2 id="二、听话，出活"><a href="#二、听话，出活" class="headerlink" title="二、听话，出活"></a>二、听话，出活</h2><p>　　“什么叫好员工啊，好员工特简单，就四个字：听话、出活”。这是至理名言。</p>
<p>　　什么叫“听话”?有句老话叫“干活不由东，累死也无功”，谁是“东”啊?你的直属领导就是“东”，大部分时候，听他的话准没错儿。</p>
<p>　　有朋友说：我有能力，我比领导水平高，我就不听领导的!咱先不说到底谁水平高——既然他能当你领导，肯定有比你强的地方——咱就说水平和能力这事儿，什么叫“有能力”啊?领导用你，你就有能力。不用你，甭管您有再大的能力，都是白费。</p>
<p>　　根据我的经验，一般来说，领导都比你水平高，起码在一点上是这样：他比你信息更全面、判断的更准确。因为领导更容易接触到更高层，更了解更高层的意图，他知道的你不知道，你在自己的角度上认为“这么做对”，但领导在更高的层面，并不一定这么看。</p>
<p>　　还有朋友说我领导就是瞎指挥，明摆着不对，我干嘛要听他的?这是另外一个问题，咱们最后一条会谈到，如果你觉得现在的环境无法进步，就可以考虑离职了。</p>
<p>　　什么叫“出活”?就是领导给你的工作，你得按时完成并且汇报总结。如果这个工作要持续较长时间，那么你需要阶段性的给领导反馈。我们经常犯一个错误，领导安排的工作，他不问你也不说，黑不提白不提这事儿就算过去了。</p>
<p>　　过去了?哪儿那么容易啊!领导都记着呢，你等他问你的时候——“诶小陈，上次安排你做的那事儿怎么样了?”——他就已经在心里给你写上了标签：“不靠谱”。</p>
<p>　　一个“不靠谱”需要用十个“靠谱”来扭转，两个“不靠谱”就很难转变印象，三个“不靠谱”你就没有机会了。</p>
<h2 id="三、要想人前显贵，必须背地里受罪"><a href="#三、要想人前显贵，必须背地里受罪" class="headerlink" title="三、要想人前显贵，必须背地里受罪"></a>三、要想人前显贵，必须背地里受罪</h2><p>　　在公司里上班，大家的智商都差不多，谁也不比谁强多少，拼的都是努力和用心的程度。你下功夫了，就比别人做得好。哦，本来就不比别人聪明，别人下班你也下班、别人玩儿你也玩儿、别人搞对象你也泡马子，你凭什么比别人干得好?</p>
<p>　　“要想人前显贵，必须背地里受罪”的道理并不难懂。就是真到受苦的时候就含糊了，有的人会说，我年纪轻轻的为什么不好好享受生活啊?这种想法很 普遍，这本是一个价值观的问题，没什么可说的，一个人想怎么生活都对。但是有一些朋友是在追求理想和享受生活中纠结的，和这些朋友，是可以聊的。</p>
<p>　　马云曾经说过：我们追求的应是人生的大平衡，而不是一时一日的小平衡(大意如此)。新东方也有一句话说：怕吃苦吃苦一辈子，不怕苦吃苦半辈子。两句话大意相同，值得深思。</p>
<p>　　一件工作，你用心想了做了，领导一看就知道，你想糊弄，也是一看就知道，这个没侥幸。领导在判断这个问题的时候，标准很简单：我想到的，你都没想到，肯定没用心;我想到的，你想到了一部分，用心不够;我没想到的，你想到了，这是用心了——这就是“超预期”(“出活”还有一层含义，就是“超预期”。)。如果你每次都能给你的老板一个超预期的 结果，那你无疑就是一个好员工。</p>
<h2 id="四、能忍多大事儿，就能成多大事儿"><a href="#四、能忍多大事儿，就能成多大事儿" class="headerlink" title="四、能忍多大事儿，就能成多大事儿"></a>四、能忍多大事儿，就能成多大事儿</h2><p>　　在工作上想受到领导的赏识和重用，除了要有过硬的工作能力外，更重要的，要有足够的涵养(抗压力或者回血能力)。能受多大委屈，才能成多大事儿，这是一定的。为了考察你的“抗压力”，领导有时会故意试你，你可一定要经得住考验。</p>
<h2 id="五、总躲着领导，你就危险了"><a href="#五、总躲着领导，你就危险了" class="headerlink" title="五、总躲着领导，你就危险了"></a>五、总躲着领导，你就危险了</h2><p>　　不少人躲着领导，尽量少跟领导说话、绕着领导走。因为跟领导近了事儿就多，不跟领导多接触，事儿少，多清闲。这是“一叶障目，不见泰山”。</p>
<p>　　如果你想在工作上取得一些成绩，我建议还是应该主动的多和领导沟通。领导在平时开会时说的多是大面儿上的话，真话、有用的话、有价值的话不一定说。这并不是他不想说，而是没机会说。</p>
<p>　　有心的员工会随时抽时间和领导沟通、增加私人交流的机会：一起吃饭、一起抽烟、一起上下班、甚至一起打球K歌……通过这样的机会，你可以了解领导对于你的看法、对于工作的观点，这些都有益于你调整自己的工作的方式。</p>
<p>　　有朋友担心这样做会引起领导反感，其实完全不会，领导们多是孤独的，如果他发现有一个员工虚心向他请教、积极分享工作的思考，他是非常高兴的。</p>
<p>　　有朋友说，我不想那么累，我就想混混日子。即便是这样，你最好也主动和领导沟通、主动汇报。你追着他，你是主动的一方，其实你不累;等到他追你的时候，你就被动了，最终就累死了。</p>
<p>　　老罗曾经讲过一个故事，说你进入单位，见到老板就低头过去、不理他，他当然也不理你。等到年终考核、或者裁员的时候，老板隐约记得有你这么个人，但不知道你的名字、更不知道你做了什么。老板会想：这是你的错，不是我的错。不开除你开除谁?</p>
<p>　　老板也是人，大家用人类的方式沟通，一切会变得简单很多。</p>
<h2 id="六、帮助别人千万别吝啬"><a href="#六、帮助别人千万别吝啬" class="headerlink" title="六、帮助别人千万别吝啬"></a>六、帮助别人千万别吝啬</h2><p>　　马云曾经说，成功就是成就自己帮助别人。这话没错。</p>
<p>　　如果你在一家公司工作，你发现你的工作不用任何人协助就能自己独立完成，那你多半是个打杂的。相反，你的工作需要越多人协作，就越复杂、越高级。在实际工作中我发现，我处在一个协作关系网中，如果没有别人的帮助，我就无法工作下去。</p>
<p>　　当你正在忙于某项工作时，有同事来向你“求助”，很多时候我们会很直接、甚至粗暴的拒绝，殊不知这样做正在给你今后的工作种下麻烦的种子。风水 轮流转，在一家公司里，大家的工作互相交叉的几率很大，说不定你会用上谁，这些人脉关系需要平时去维护。今天你帮助了人家，说不定明天对方就会成为你的救 命稻草，这非常可能。</p>
<p>　　有一天我正在疲于应付一个项目总结，这时有个其他部门的同事来找我聊合作的事儿，我并不认识他，我耐心的和他介绍了情况，并且真的形成了几次愉快的合作，半年后，我的晋升答辩会上，我发现他是我的答辩委员……</p>
<h2 id="七、目标再目标，量化再量化"><a href="#七、目标再目标，量化再量化" class="headerlink" title="七、目标再目标，量化再量化"></a>七、目标再目标，量化再量化</h2><p>　　没有目标的，都不叫工作;没有量化的，都不叫目标。</p>
<p>　　在接受一项工作时，先问目标是什么;在布置一项工作时，先交代目标是什么。这个不说清楚，都是扯淡。</p>
<p>　　不想成为蒙着眼睛拉磨的驴?那么除了清楚的知道自己的目标外，还得知道你的部门、你的公司的目标，最关键的，你需要知道，你的工作在总体目标中处在什么地位、扮演什么角色。如果你发现，你工作的目标和总体目标关系很小、甚至没有关系，那么你就很容易被拿掉。</p>
<p>　　辞退员工，或给员工绩效打分“不合格”是很令人头疼的，但其实这事儿并不难。关键就在于事先和每个员工一起制定量化的工作目标，并且随时提醒员 工，他的工作是否达到了要求。没有达到量化指标，辞退或“不合格”是令所当然事儿，在数据面前，再矫情的人也无话可说。相反，如果谈感觉、聊希望，这事儿 就没法办了。</p>
<h2 id="八、找到解决问题的办法是我的义务"><a href="#八、找到解决问题的办法是我的义务" class="headerlink" title="八、找到解决问题的办法是我的义务"></a>八、找到解决问题的办法是我的义务</h2><p>　　领导安排的工作，不能说“我做不了”、“我做不到”。</p>
<p>　　公司请我们来工作，是为了解决问题的，如果不能解决问题，我们就没有价值。工作推进中遇到困难，无法继续进行，这是很正常的事儿，我们需要做的是主动寻找答案和办法，哪怕你的办法不妥，那么就去问，但无论如何不能对你的领导说，我不会。</p>
<p>　　前天，我在公司里听见隔壁团队的领导安排同事定一个会议室，有公司工作经验的人都知道，会议室是很难订到的，弄不好还需要“托关系，走后门”。这个小同学可能是没有订到，于是和他的领导说“我没订到”，他的领导直接就急了，说：“那怎么办?需要我来订吗?”</p>
<p>　　这位领导发火是有道理的，这位小同学在发现自己订不到会议室后，应该做的是自己想办法解决问题——最简单的就是向老同事咨询。</p>
<p>　　解决问题的能力是员工最关键的能力，没有之一。在工作中遇到困难特别正常，在这时，我们有一项义务，就是找到解决问题的办法。</p>
<h2 id="九、尽量不说“不是我，我没有”"><a href="#九、尽量不说“不是我，我没有”" class="headerlink" title="九、尽量不说“不是我，我没有”"></a>九、尽量不说“不是我，我没有”</h2><p>　　绝大多数人在面对批评的时候，本能反应都是推卸责任，此时的口头禅就是“不是我”、“没有我”。我总觉得，很多时候，越成熟的人，就越少用本能反应面对问题，因为他们有更强的自控力。</p>
<p>　　尽量不说“不是我”、“没有我”这样的话，因为这些话毫无作用，领导听惯了这样的推卸之词，丝毫不会为之所动。此时如果能够主动承担责任，反而体现了一种担</p>
<p>　　当。即便真是被冤枉了，当场辩解往往也不是最明智的选择，可以先保持沉默，私下找机会和领导进行沟通。这个详见第三条。</p>
<h2 id="十、“言多必失”死得惨"><a href="#十、“言多必失”死得惨" class="headerlink" title="十、“言多必失”死得惨"></a>十、“言多必失”死得惨</h2><p>　　在公司里，少说闲话，不说是非话，不做是非人。</p>
<p>　　你就相信一点：你说的每句话，你的老板都会知道。好话可能不一定，坏话则是一定的。</p>
<p>　　还是做个正直的人吧，这样最简单，也受益最大。正直人的原则是：批评当面说，赞美背后讲。</p>
<h2 id="十一、知道什么时候离开"><a href="#十一、知道什么时候离开" class="headerlink" title="十一、知道什么时候离开"></a>十一、知道什么时候离开</h2><p>　　好多同事和朋友和我聊过离职的话题，我对朋友们的建议是，如果你因为觉得工作不爽，那就别离职，因为甭管到哪里，都会不爽：老板不喜欢、同事不可爱、工作太劳累、关系太复杂……我以我在多家大公司工作的经历担保：几乎所有我工作过的公司，令人不爽的事儿都是一样的。</p>
<p>　　那么什么时候离开呢?我想，有两种情况：</p>
<p>　　1、在这家公司，你已经没有上升的空间、无法学习到更多的东西了;</p>
<p>　　2、在这家公司，你已学到足够的知识，可以在新领域或新平台上一展身手了。</p>
<p>###本文转载自：<a href="http://news.cnblogs.com/n/213563/" target="_blank" rel="noopener">http://news.cnblogs.com/n/213563/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://huwj.work/%E7%82%B9%E6%BB%B4%E7%94%9F%E6%B4%BB/%E8%81%8C%E5%9C%BA" data-id="ck3gl3nus002bvkez7nj235z4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-动态绑定" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/java/%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A" class="article-date">
  <time datetime="2018-10-10T12:12:59.000Z" itemprop="datePublished">2018-10-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/java/%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A">动态绑定</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>说实话，我得脑子已经不够我再去学习更多的东西了，因为今年实在是学习了太多的java知识，还是挺开心的，记录一下这美好的时刻吧。</p>
<h2 id="多态动态绑定"><a href="#多态动态绑定" class="headerlink" title="多态动态绑定"></a>多态动态绑定</h2><p> 1成员方法——–&gt;成员方法在多态中参与动态绑定，在 fu a =new zi()中，a.方法();显示的是子类中的方法。</p>
<p> 2成员变量——–&gt;比较复杂，对于直接的public定义的变量，在   fu a =new zi()过程中，因为参数不参与动态绑定，所以a.num执行的仍未fu类中的num值。但是若将num进行private封装，则在fu类zi类中需建立getNum方法，方法参与动态绑定，故a.getNum();显示的值为zi类中的num数据。</p>
<p> 3还有一个就是static，其实静态作为一个方法或者变量，在类初始化之后变已经存在，直接类名调用即可。</p>
<p> 4final 放在类之前，不允许继承，放在方法前，不允许被覆写。<br><img src="/images/java/dongtai/1.png" alt="Alt text"><br><img src="/images/java/dongtai/0.png" alt="Alt text"><br><img src="/images/java/dongtai/3.png" alt="Alt text"><br>关于java动态绑定的一个好文章：<a href="https://www.cnblogs.com/xdp-gacl/p/3644035.html" target="_blank" rel="noopener">https://www.cnblogs.com/xdp-gacl/p/3644035.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://huwj.work/java/%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A" data-id="ck3gl3nty001kvkez14vdavmb" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-this-super" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/java/this-super" class="article-date">
  <time datetime="2018-10-10T03:29:58.000Z" itemprop="datePublished">2018-10-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/java/this-super">this/super</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>其实有时候java也没那么可怕，今天来讲讲两个很让人头大的关键字this&amp;super</p>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>(1)this调用本类中的属性，也就是类中的成员变量；</p>
<p>(2)this调用本类中的其他方法；</p>
<p>(3)this调用本类中的其他构造方法，调用时要放在构造方法的首行。<br>其实可以简化为两个：（根据java核心技卷一）</p>
<p>1.引用隐式参数，</p>
<p>2.调用改类的其他构造器。</p>
<p>如图所示：<br><img src="/images/java/this/0.png" alt="Alt text"></p>
<h3 id="应用一：引用成员变量"><a href="#应用一：引用成员变量" class="headerlink" title="应用一：引用成员变量"></a>应用一：引用成员变量</h3><pre><code>Public Class Student {
String name; //定义一个成员变量name
private void SetName(String name)//定义一个参数(局部变量)name 
{ 
this.name=name; //将局部变量的值传递给成员变量
}
}        </code></pre><p>this这个关键字其代表的就是对象中的成员变量或者方法。也就是说，如果在某个变量前面加上一个this关键字，其指的就是这个对象的成员变量或者方法，而不是指成员方法的形式参数或者局部变量。     </p>
<p>为此在上面这个代码中，this.name代表的就是对象中的成员变量，又叫做对象的属性，而后面的name则是方法的形式参数，代码this.name=name就是将形式参数的值传递给成员变量。</p>
<h3 id="应用二：调用类的构造方法"><a href="#应用二：调用类的构造方法" class="headerlink" title="应用二：调用类的构造方法"></a>应用二：调用类的构造方法</h3><pre><code>public class Student { //定义一个类，类的名字为student。
public Student() { //定义一个方法，名字与类相同故为构造方法  
this(“Hello!”); //调用该类的其他构造器
} 
public Student(String name) { //定义一个带形式参数的构造方法 
}</code></pre><p>在一个类中可以存在多个构造方法，这些构造方法都采用相同的名字，只是形式参数不同。Java语言就凭形式参数不同来判断调用那个构造方法。在本例中，在无参构造器中师兄this(“Hello”)调用下面的带参构造函数。</p>
<h3 id="应用三：返回对象的值"><a href="#应用三：返回对象的值" class="headerlink" title="应用三：返回对象的值"></a>应用三：返回对象的值</h3><h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2><p>1.调用父类的方法<br>2.调用父类的构造器函数<br><img src="/images/java/this/1.png" alt="Alt text"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://huwj.work/java/this-super" data-id="ck3gl3ntr001hvkez8serfogl" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-String-StringBuilder-StringBuffer" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/java/String-StringBuilder-StringBuffer" class="article-date">
  <time datetime="2018-10-09T12:15:06.000Z" itemprop="datePublished">2018-10-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/java/String-StringBuilder-StringBuffer">String/StringBuilder/StringBuffer</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-String-StringBuffer与StringBuilder的区别"><a href="#1-String-StringBuffer与StringBuilder的区别" class="headerlink" title="1. String,StringBuffer与StringBuilder的区别"></a>1. String,StringBuffer与StringBuilder的区别</h2><p>String：存储在常量池中；是不可变的字符序列，任何对String值的改变都会引发新的String对象的生成，因此执行字符串值改变的操作时效率很低，此时一般选择StingBuffer或者StringBuilder；支持并发操作，是线程安全的 ；</p>
<p>StringBuffer 和 StringBuilder都是可变字符串；new出的对象存储在堆中；主要区别在于：</p>
<p>StringBuffer：是线程安全的，因此牺牲了一定的效率来维护同步锁；</p>
<p>StringBuilder：线程不安全，效率最高；</p>
<p>StringBuilder可以操作StringBuffer，但是StringBuffer不可以操作StringBuilder，这也是线程的原因；</p>
<p>总结：效率：StringBuilder&gt;StringBuffer&gt;String；所以，如果这是考虑单线程程序的话，用StringBuilder，如果涉及到多线程的，考虑到线程安全问题只能用StringBuffer。</p>
<h2 id="2-String"><a href="#2-String" class="headerlink" title="2. String"></a>2. String</h2><p>String 类型和 StringBuffer 类型的主要性能区别其实在于 String 是不可变的对象, 因此在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要用 String ，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后， JVM 的 GC 就会开始工作，那速度是一定会相当慢的。</p>
<p>而如果是使用 StringBuffer 类则结果就不一样了，每次结果都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，再改变对象引用。所以在一般情况下我们推荐使用 StringBuffer ，特别是字符串对象经常改变的情况下。而在某些特别情况下， String 对象的字符串拼接其实是被 JVM 解释成了 StringBuffer 对象的拼接，所以这些时候 String 对象的速度并不会比 StringBuffer 对象慢，而特别是以下的字符串对象生成中， String 效率是远要比 StringBuffer 快的：</p>
<pre><code>String S1 = “This is only a” + “ simple” + “ test”;
StringBuffer Sb = new StringBuilder(“This is only a”).append(“ simple”).append(“ test”);</code></pre><p>你会很惊讶的发现，生成 String S1 对象的速度简直太快了，而这个时候 StringBuffer 居然速度上根本一点都不占优势。其实这是 JVM 的一个把戏，在 JVM 眼里，这个</p>
<p><code>String S1 = “This is only a” + “ simple” + “test”;</code> <br><br>其实就是：<br><code>String S1 = “This is only a simple test”;</code><br>所以当然不需要太多的时间了。但大家这里要注意的是，如果你的字符串是来自另外的 String 对象的话，速度就没那么快了，譬如：</p>
<pre><code>String S2 = “This is only a”;
String S3 = “ simple”;
String S4 = “ test”;
String S1 = S2 +S3 + S4;</code></pre><p>这时候 JVM 会规规矩矩的按照原来的方式去做</p>
<p><strong>在大部分情况下 StringBuffer &gt; String</strong></p>
<h2 id="3-StringBuffer"><a href="#3-StringBuffer" class="headerlink" title="3. StringBuffer"></a>3. StringBuffer</h2><p>Java.lang.StringBuffer线程安全的可变字符序列。一个类似于 String 的字符串缓冲区，但不能修改。虽然在任意时间点上它都包含某种特定的字符序列，但通过某些方法调用可以改变该序列的长度和内容。可将字符串缓冲区安全地用于多个线程。可以在必要时对这些方法进行同步，因此任意特定实例上的所有操作就好像是以串行顺序发生的，该顺序与所涉及的每个线程进行的方法调用顺序一致。<br>StringBuffer 上的主要操作是 append 和 insert 方法，可重载这些方法，以接受任意类型的数据。每个方法都能有效地将给定的数据转换成字符串，然后将该字符串的字符追加或插入到字符串缓冲区中。append 方法始终将这些字符添加到缓冲区的末端；而 insert 方法则在指定的点添加字符。</p>
<pre><code>例如，如果 z 引用一个当前内容是“start”的字符串缓冲区对象，
则此方法调用 z.append(&quot;le&quot;) 会使字符串缓冲区包含“startle”，
而 z.insert(4, &quot;le&quot;) 将更改字符串缓冲区，使之包含“starlet”。
在大部分情况下 StringBuilder &gt; StringBuffer</code></pre><h2 id="4-StringBuilder"><a href="#4-StringBuilder" class="headerlink" title="4. StringBuilder"></a>4. StringBuilder</h2><p>java.lang.StringBuilder一个可变的字符序列是5.0新增的。此类提供一个与 StringBuffer 兼容的 API，但不保证同步。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。如果可能，建议优先采用该类，因为在大多数实现中，它比 StringBuffer 要快。两者的方法基本相同。</p>
<h2 id="5-StringBuffer的主要方法介绍"><a href="#5-StringBuffer的主要方法介绍" class="headerlink" title="5. StringBuffer的主要方法介绍"></a>5. StringBuffer的主要方法介绍</h2><p>（由于StringBuffer和StringBuilder在使用上几乎一样，所以只写一个，以下部分内容网络各处收集，不再标注出处）</p>
<pre><code>StringBuffer s = new StringBuffer();</code></pre><p>这样初始化出的StringBuffer对象是一个空的对象，</p>
<pre><code>StringBuffer sb1=new StringBuffer(512);</code></pre><p>分配了长度512字节的字符缓冲区。 </p>
<pre><code>StringBuffer sb2=new StringBuffer(“how are you?”)</code></pre><p>创建带有内容的StringBuffer对象，在字符缓冲区中存放字符串</p>
<p><code>“how are you?”</code></p>
<h2 id="a、append方法"><a href="#a、append方法" class="headerlink" title="a、append方法"></a>a、append方法</h2><pre><code>public StringBuffer append(boolean b)</code></pre><p>该方法的作用是追加内容到当前StringBuffer对象的末尾，类似于字符串的连接，调用该方法以后，StringBuffer对象的内容也发生改 变，例如：</p>
<pre><code>StringBuffer sb = new StringBuffer(“abc”);
sb.append(true);</code></pre><p>则对象sb的值将变成”abctrue”</p>
<p>使用该方法进行字符串的连接，将比String更加节约内容，经常应用于数据库SQL语句的连接。</p>
<h2 id="b、deleteCharAt方法"><a href="#b、deleteCharAt方法" class="headerlink" title="b、deleteCharAt方法"></a>b、deleteCharAt方法</h2><pre><code>public StringBuffer deleteCharAt(int index)</code></pre><p>该方法的作用是删除指定位置的字符，然后将剩余的内容形成新的字符串。例如：</p>
<pre><code>StringBuffer sb = new StringBuffer(“KMing”);
sb. deleteCharAt(1);</code></pre><p>该代码的作用删除字符串对象sb中索引值为1的字符，也就是删除第二个字符，剩余的内容组成一个新的字符串。所以对象sb的值变 为”King”。<br>还存在一个功能类似的delete方法：</p>
<pre><code>`public StringBuffer delete(int start,int end)`</code></pre><p>该方法的作用是删除指定区间以内的所有字符，包含start，不包含end索引值的区间。例如：</p>
<pre><code>StringBuffer sb = new StringBuffer(“TestString”);
sb. delete (1,4);</code></pre><p>该代码的作用是删除索引值1(包括)到索引值4(不包括)之间的所有字符，剩余的字符形成新的字符串。则对象sb的值是”TString”。 前包括后不包括方法。</p>
<h2 id="c、insert方法"><a href="#c、insert方法" class="headerlink" title="c、insert方法"></a>c、insert方法</h2><pre><code>public StringBuffer insert(int offset, boolean b),</code></pre><p>该方法的作用是在StringBuffer对象中插入内容，然后形成新的字符串。例如：</p>
<pre><code>`StringBuffer sb = new StringBuffer(“TestString”);
 sb.insert(4,false);`</code></pre><p>该示例代码的作用是在对象sb的索引值4的位置插入false值，形成新的字符串，则执行以后对象sb的值是”TestfalseString”。 </p>
<h2 id="d、reverse方法"><a href="#d、reverse方法" class="headerlink" title="d、reverse方法"></a>d、reverse方法</h2><pre><code>public StringBuffer reverse()</code></pre><p>该方法的作用是将StringBuffer对象中的内容反转，然后形成新的字符串。例如：</p>
<pre><code>`StringBuffer sb = new StringBuffer(“abc”);
 sb.reverse();`</code></pre><p>经过反转以后，对象sb中的内容将变为”cba”。 </p>
<h2 id="e、setCharAt方法"><a href="#e、setCharAt方法" class="headerlink" title="e、setCharAt方法"></a>e、setCharAt方法</h2><pre><code>public void setCharAt(int index, char ch)</code></pre><p>该方法的作用是修改对象中索引值为index位置的字符为新的字符ch。例如：</p>
<pre><code>`StringBuffer sb = new StringBuffer(“abc”);
sb.setCharAt(1,’D’);`</code></pre><p>则对象sb的值将变成”aDc”。 </p>
<h2 id="f、trimToSize方法"><a href="#f、trimToSize方法" class="headerlink" title="f、trimToSize方法"></a>f、trimToSize方法</h2><p>public void trimToSize()<br>该方法的作用是将StringBuffer对象的中存储空间缩小到和字符串长度一样的长度，减少空间的浪费，和String的trim()是一样的作用，不在举例。</p>
<h2 id="g、length方法"><a href="#g、length方法" class="headerlink" title="g、length方法"></a>g、length方法</h2><p>该方法的作用是获取字符串长度 ，不用再说了吧。</p>
<h2 id="h、setlength方法"><a href="#h、setlength方法" class="headerlink" title="h、setlength方法"></a>h、setlength方法</h2><p>该方法的作用是设置字符串缓冲区大小。</p>
<pre><code>`StringBuffer sb=new StringBuffer();
sb.setlength(100);`</code></pre><p>如果用小于当前字符串长度的值调用setlength()方法，则新长度后面的字符将丢失。 </p>
<h2 id="i、sb-capacity方法"><a href="#i、sb-capacity方法" class="headerlink" title="i、sb.capacity方法"></a>i、sb.capacity方法</h2><p>该方法的作用是获取字符串的容量。</p>
<pre><code>`StringBuffer sb=new StringBuffer(“string”);
int i=sb.capacity(); `</code></pre><h2 id="j、ensureCapacity方法"><a href="#j、ensureCapacity方法" class="headerlink" title="j、ensureCapacity方法"></a>j、ensureCapacity方法</h2><p>该方法的作用是重新设置字符串容量的大小。</p>
<pre><code>`StringBuffer sb=new StringBuffer();
sb.ensureCapacity(32); //预先设置sb的容量为32 `</code></pre><h2 id="k、getChars方法"><a href="#k、getChars方法" class="headerlink" title="k、getChars方法"></a>k、getChars方法</h2><p>该方法的作用是将字符串的子字符串复制给数组。</p>
<pre><code>`getChars(int start,int end,char chars[],int charStart); 

StringBuffer sb = new StringBuffer(&quot;I love You&quot;);
int begin = 0;
int end = 5;
//注意ch字符数组的长度一定要大于等于begin到end之间字符的长度
//小于的话会报ArrayIndexOutOfBoundsException
//如果大于的话，大于的字符会以空格补齐
char[] ch  = new char[end-begin];
sb.getChars(begin, end, ch, 0);
System.out.println(ch);`</code></pre><p>结果：I lov</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://huwj.work/java/String-StringBuilder-StringBuffer" data-id="ck3gl3nq30003vkez3siehz9j" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-word加页码" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/office/word%E5%8A%A0%E9%A1%B5%E7%A0%81" class="article-date">
  <time datetime="2018-09-28T13:35:08.000Z" itemprop="datePublished">2018-09-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/office/">office</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/office/word%E5%8A%A0%E9%A1%B5%E7%A0%81">word加页码</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这几天通过办公时发现，自己的word以及excle功底可谓相当的差劲了，很多事情根本不会，例如excle上面找一个筛选排序都不行，今天word加页码也很抠脚，索性写一篇文章来记录一下office学习。</p>
<h2 id="word加页码，比较复杂，尤其想在第二页上加“1”页码，也就是将第2页作为第1页。"><a href="#word加页码，比较复杂，尤其想在第二页上加“1”页码，也就是将第2页作为第1页。" class="headerlink" title="word加页码，比较复杂，尤其想在第二页上加“1”页码，也就是将第2页作为第1页。"></a>word加页码，比较复杂，尤其想在第二页上加“1”页码，也就是将第2页作为第1页。</h2><p>这里再需要将鼠标光标点击到开始编页码的前一页末尾，也就是第1页末尾，然后点击菜单栏的<strong>“页面布局”</strong>，在“页面布局”栏目下，点击分隔符后面的倒三角形，弹出<strong>分隔符</strong>的相关功能栏目，点击<strong>“下一页”</strong>如红色方框所示：<img src="/images/office/00.png" alt="Alt text"><br>设置需要插入到额页码格式<br><img src="/images/office/0.png" alt="Alt text"><br>点击“插入”→“页码”→页码位置，如“页面底端”→“普通数字2”<br><img src="/images/office/1.png" alt="Alt text"><br>取消分节链接<br><br>双击需要插入页码的任意一页的页眉或页脚，如在需要插入页码的第一页的页码附近双击一下，点击“设计”→“链接到前一条页眉”，将链接到前一条页眉取消掉，此时图标显示为灰色。<br><img src="/images/office/2.png" alt="Alt text"><br>删除前面不需要的页码<br><br>双击页眉或页脚后，我们可以看到“第一节”或“第二节”的字样，选中第一节的页码，直接按键盘“Delete”键将页码删除，双击其它任意空白位置，我们可以发现第一节的页码被删除，而第二节的页码没有任何变化。<br><img src="/images/office/3.png" alt="Alt text"></p>
<p><strong>注意：</strong>删除前面不需要的页码的时候，一定要先点击“设计”→“链接到前一条页眉”，将链接到前一条页眉取消掉。否则删除前面的页码的同时也会把后面的页码删除。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://huwj.work/office/word%E5%8A%A0%E9%A1%B5%E7%A0%81" data-id="ck3gl3ntn001fvkez8wdoe62f" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-openstack跟hadoop区别" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/%E4%BA%91%E8%AE%A1%E7%AE%97/openstack%E8%B7%9Fhadoop%E5%8C%BA%E5%88%AB" class="article-date">
  <time datetime="2018-09-22T08:54:48.000Z" itemprop="datePublished">2018-09-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/">云计算</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/%E4%BA%91%E8%AE%A1%E7%AE%97/openstack%E8%B7%9Fhadoop%E5%8C%BA%E5%88%AB">openstack跟hadoop区别</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>openstack仿照的Amazon的云，hadoop仿照的是Google的云</p>
<p>openstack注重的是虚拟化/虚拟机及其配套的服务，hadoop注重的是海量的数据分析和处理。</p>
<hr>
<p>OpenStack 主要目的是做一整套的云计算基础构架。包括 云计算(Compute), 网络(Network)，对象存贮(Object Store)，镜像文件存储 (Image)，身份认证(Authentication)，BlockStorage 以及 前端UI 。</p>
<p>OpenStack的每个模块都对外提供API，可以独立供云用户调用，在OpenStack内部，每个模块之间的相互调用也是用这些API.</p>
<p>而 Hadoop 是一个分布式数据库。举个例子：OpenStack 中 Object Store 模块可以选择用Hadoop来支持。如果把 Openstack 比作WIndows的话，Hadoop 相当于Sql Server。</p>
<hr>
<p>openstack是管理虚拟机的，比如xen，kvm等。它所谓的云就是一堆的虚拟机。</p>
<p>hadoop是负责分布式计算和分布式存储。就是把一个执行任务分开，放到不同的节点（物理机）去跑，最后汇总。</p>
<hr>
<p>OpenStack是IaaS(基础设施即服务)‎虚拟机管理软件，让任何人都可以自行建立和提供云端运算服务。<br>而hadoop是一个分布式文件系统+分布式计算平台的开源方案，侧重于hdfs云存储与mapreduce云数据分析等方面</p>
<hr>
<p>OpenStack主要做资源的虚拟化，Hadoop主要用来做超大数据处理，还可以做数据挖掘</p>
<hr>
<p>Openstack是把大机器虚拟成很多小机器从而达到大的分成小的来用，大大提高资源使用率。<br>Hadoop是把小机器合起来用，用于解决单台大机器无法解决的计算和存储等问题。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://huwj.work/%E4%BA%91%E8%AE%A1%E7%AE%97/openstack%E8%B7%9Fhadoop%E5%8C%BA%E5%88%AB" data-id="ck3gl3nso000uvkez2cid85eu" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-死锁" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/uncategorized/%E6%AD%BB%E9%94%81" class="article-date">
  <time datetime="2018-09-21T03:15:51.000Z" itemprop="datePublished">2018-09-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/uncategorized/%E6%AD%BB%E9%94%81">死锁</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://huwj.work/uncategorized/%E6%AD%BB%E9%94%81" data-id="ck3gl3nuk0024vkezbvj24cns" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-static关键字" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/java/static%E5%85%B3%E9%94%AE%E5%AD%97" class="article-date">
  <time datetime="2018-09-21T02:20:00.000Z" itemprop="datePublished">2018-09-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/java/static%E5%85%B3%E9%94%AE%E5%AD%97">static关键字</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>static、final等关键字感觉这对于初级码农来说，是一个世界性的难题，我也不知道对它的理解如何，总之，现在仍是云里雾里，过段时间看看JVM吧，总之，不想做一名只会增删改查的程序员，就要不断地学习。</p>
<h2 id="1、static变量"><a href="#1、static变量" class="headerlink" title="1、static变量"></a>1、static变量</h2><p>按照是否静态的对类成员变量进行分类可分两种：一种是被static修饰的变量，叫静态变量或类变量；另一种是没有被static修饰的变量，叫实例变量。<br><br>两者的区别是：<br><br>对于静态变量在内存中只有一个拷贝（节省内存），JVM只为静态分配一次内存，在加载类的过程中完成静态变量的内存分配，可用类名直接访问（方便），当然也可以通过对象来访问（但是这是不推荐的）。<br><br>对于实例变量，每创建一个实例，就会为实例变量分配一次内存，实例变量可以在内存中有多个拷贝，互不影响（灵活）。<br><br>所以一般在需要实现以下两个功能时使用静态变量：<br><br>1).在对象之间共享值时<br><br>2).方便访问变量时<br></p>
<h2 id="2、静态方法"><a href="#2、静态方法" class="headerlink" title="2、静态方法"></a>2、静态方法</h2><p>静态方法可以直接通过类名调用，任何的实例也都可以调用<br></p>
<p>因此静态方法中不能用this和super关键字，不能直接访问所属类的实例变量和实例方法(就是不带static的成员变量和成员成员方法)，只能访问所属类的静态成员变量和成员方法。</p>
<p>因为实例成员与特定的对象关联！这个需要去理解，想明白其中的道理，不是记忆！！！</p>
<p>因为static方法独立于任何实例，因此static方法必须被实现，而不能是抽象的abstract。</p>
<p>例如为了方便方法的调用，Java API中的Math类中所有的方法都是静态的，而一般类内部的static方法也是方便其它类对该方法的调用。</p>
<p>静态方法是类内部的一类特殊方法，只有在需要时才将对应的方法声明成静态的，一个类内部的方法一般都是非静态的。</p>
<h2 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h2><p>static代码块也叫静态代码块，是在类中独立于类成员的static语句块，可以有多个，位置可以随便放，它不在任何的方法体内，JVM加载类时会执行这些静态的代码块，如果static代码块有多个，JVM将按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次。<br><img src="/images/java/static/1.png" alt="Alt text"></p>
<p><strong>综上：简言之，静态变量为共享的，静态方法可以直接被类名调用，静态代码块依次没虚拟机初始化。</strong></p>
<h2 id="static和final一块用"><a href="#static和final一块用" class="headerlink" title="static和final一块用"></a>static和final一块用</h2><p>static final用来修饰成员变量和成员方法，可简单理解为“<strong>全局常量</strong>”！</p>
<p>对于变量，表示一旦给值就不可修改，并且通过类名可以访问。</p>
<p>对于方法，表示不可覆盖，并且可以通过类名直接访问。</p>
<p>有时你希望定义一个类成员，使它的使用完全独立于该类的任何对象。通常情况下，类成员必须通过它的类的对象访问，但是可以创建这样一个成员，它能够被它自己使用，而不必引用特定的实例。在成员的声明前面加上关键字static(静态的)就能创建这样的成员。如果一个成员被声明为static，它就能够在它的类的任何对象创建之前被访问，而不必引用任何对象。<strong>你可以将方法和变量都声明为static。static 成员的最常见的例子是main( ) 。因为在程序开始执行时必须调用main() ，所以它被声明为static。</strong></p>
<p><strong>声明为static的变量实质上就是全局变量</strong>。当声明一个对象时，并不产生static变量的拷贝，而是该类所有的实例变量共用同一个static变量。声明为static的方法有以下几条限制：</p>
<p>1).它们仅能调用其他的static 方法。</p>
<p>2).它们只能访问static数据。</p>
<p>3).它们不能以任何方式引用this 或super</p>
<p>如果你需要通过计算来初始化你的static变量，你可以声明一个static块，Static 块仅在该类被加载时执行一次。下面的例子显示的类有一个static方法，一些static变量，以及一个static 初始化块：<br><img src="/images/java/static/0.png" alt="Alt text"></p>
<p>一旦UseStatic 类被装载，所有的static语句被运行。首先，a被设置为3，接着static 块执行(打印一条消息)，最后，b被初始化为a*4 或12。然后调用main()，main() 调用meth() ，把值42传递给x。3个println ( ) 语句引用两个static变量a和b，以及局部变量x 。<br><img src="/images/java/static/1.png" alt="Alt text"></p>
<p><strong>注意：在一个static 方法中引用任何实例变量都是非法的。</strong></p>
<p>在定义它们的类的外面，<strong>static 方法和变量能独立于任何对象而被使用。</strong>这样，你只要在类的名字后面加点号运算符即可。例如，如果你希望从类外面调用一个static方法，你可以使用下面通用的格式：<br><strong>classname.method( )</strong></p>
<p>这里，classname 是类的名字，在该类中定义static方法。可以看到，这种格式与通过对象引用变量调用非static方法的格式类似。一个static变量可以以同样的格式来访问——类名加点号运算符。这就是Java 如何实现全局功能和全局变量的一个控制版本。<br><img src="/images/java/static/2.png" alt="Alt text"></p>
<p>**<br>如果不加static修饰的成员是对象成员，也就是归每个对象所有的。</p>
<p>加static修饰的成员是类成员，就是可以由一个类直接调用，为所有对象共有的。**</p>
<h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p>在java中，经常希望某个变量可以在一个类中的多个方法是用，通常将这些敞亮成为类常量。可以使用static final设置一个类常量。<br><br><strong>需要注意的是：类常量的定位于main方法的外部，因此在同一个类的其他方法也可以使用这个常量，若这个常量被声明为public，那么其他类的方法也可以使用这个常量。</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://huwj.work/java/static%E5%85%B3%E9%94%AE%E5%AD%97" data-id="ck3gl3nt50019vkezhynthv7m" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-单例设计模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/java/%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F" class="article-date">
  <time datetime="2018-09-21T01:18:00.000Z" itemprop="datePublished">2018-09-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/java/%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">单例设计模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="单例设计模式定义"><a href="#单例设计模式定义" class="headerlink" title="单例设计模式定义"></a>单例设计模式定义</h2><p>定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br><br>Java中单例模式定义：“一个类有且仅有一个实例，并且自行实例化向整个系统提供。”<br>通过单例模式可以保证系统中<strong>一个类只有一个实例而且该实例易于外界访问</strong>，从而方便对实例个数的控制并节约系统资源。如果希望在系统中<strong>某个类的对象只能存在一个</strong>，单例模式是最好的解决方案。所谓一山不容二虎，一夫不容二妻，就是这个道理。<br></p>
<pre><code>public class Singleton {
   //1.将构造方法私有化，不允许外部直接创建对象
           private Singleton(){
                           }
       //2.创建类的唯一实例，使用private static修饰
   private static Singleton instance=new Singleton(); 
   //3.提供一个用于获取实例的方法，使用public static修饰
       public static Singleton getInstance(){
           return instance;
                                           }
}</code></pre><p>懒汉式：</p>
<pre><code>public class Singleton2 {

        //1.将构造方式私有化，不允许外边直接创建对象
    private Singleton2(){
                        }

    //2.声明类的唯一实例，使用private static修饰
    private static Singleton2 instance;

    //3.提供一个用于获取实例的方法，使用public static修饰
        public static Singleton2 getInstance(){
            if(instance==null){
                    instance=new Singleton2();
                            }
                            return instance;
                                            }</code></pre><p>}</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><pre><code>public class Test {
public static void main(String[] args) {

    //饿汉模式
    Singleton s1=Singleton.getInstance();
    Singleton s2=Singleton.getInstance();
    if(s1==s2){
        System.out.println(&quot;s1和s2是同一个实例&quot;);
    }else{
        System.out.println(&quot;s1和s2不是同一个实例&quot;);
    }

    //懒汉模式
    Singleton2 s3=Singleton2.getInstance();
    Singleton2 s4=Singleton2.getInstance();
    if(s3==s4){
        System.out.println(&quot;s3和s4是同一个实例&quot;);
    }else{
        System.out.println(&quot;S3和s4不是同一个实例&quot;);
    }

}
}</code></pre><p>打印结果：<br>s1和s2是同一个实例<br><br>s3和s4是同一个实例</p>
<h2 id="饿汉式VS懒汉式线程："><a href="#饿汉式VS懒汉式线程：" class="headerlink" title="饿汉式VS懒汉式线程："></a>饿汉式VS懒汉式线程：</h2><p>饿汉模式的特点是加载类时比较慢，但运行时获取对象的速度比较快，线程安全<br><br>懒汉模式的特点是加载类时比较快，但运行时获取对象的速度比较慢，线程不安全。<br><br>解决懒汉式线程不安全的方法，在懒汉式中将getInstance方法添加一个关键字synchronized。即优化后的懒汉式单例模式为：</p>
<pre><code>public class Singleton2 {

//1.将构造方式私有化，不允许外边直接创建对象
private Singleton2(){
}

//2.声明类的唯一实例，使用private static修饰
private static Singleton2 instance;

//3.提供一个用于获取实例的方法，使用public static修饰
public synchronized static Singleton2 getInstance(){
    if(instance==null){
        instance=new Singleton2();
    }
    return instance;
}
}</code></pre><p>但是常见的解决线程安全的方式为实行synchronized代码块:<br></p>
<pre><code>public class Singleton2 {

//1.将构造方式私有化，不允许外边直接创建对象
private Singleton2(){
}

//2.声明类的唯一实例，使用private static修饰
private static Singleton2 instance;

//3.提供一个用于获取实例的方法，使用public static修饰
public  static Singleton2 getInstance(){
    if(instance==null){
        synchronized(Single.class){
    if(Single==null)
         instance=new Singleton2();
        }      
    }
    return instance;
}
}</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://huwj.work/java/%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F" data-id="ck3gl3nu0001mvkez7uzjagsr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/AR/">AR</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/HTML/">HTML</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/book/">book</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/css/">css</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/js/">js</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/office/">office</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/spring/">spring</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/">云计算</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8D%9A%E5%AE%A2/">博客</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%82%B9%E6%BB%B4%E7%94%9F%E6%B4%BB/">点滴生活</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/">神经网络</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/%E7%AE%97%E6%B3%95/%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97%E4%B9%8B%E5%92%8C">最大连续子序列之和</a>
          </li>
        
          <li>
            <a href="/spring/spring-aop-1">spring_aop_代码实现</a>
          </li>
        
          <li>
            <a href="/spring/spring-aop">spring_aop</a>
          </li>
        
          <li>
            <a href="/spring/spring1">spring_DI</a>
          </li>
        
          <li>
            <a href="/java/leetcode">leetcode</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>