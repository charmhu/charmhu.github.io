{"meta":{"title":"Huwj.work","subtitle":"","description":"","author":"John Doe","url":"http://huwj.work","root":"/"},"pages":[],"posts":[{"title":"做系统遇到的问题","slug":"做系统遇到的问题","date":"2019-12-04T05:06:46.000Z","updated":"2019-12-04T05:13:50.897Z","comments":true,"path":"Windows/做系统遇到的问题/","link":"","permalink":"http://huwj.work/Windows/%E5%81%9A%E7%B3%BB%E7%BB%9F%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"Windows cannot be installed to this disk The selected disk has an MBR partition table##界面，按shift + f10， 1.进入dos界面。 2.输入 diskpart。 3.输入list disk。 4.输入select disk 。 5.输入clean 就是清除硬盘。 6.转换格式，convert mbr重装系统遇到 Windows cannot be installed to this dis。","text":"Windows cannot be installed to this disk The selected disk has an MBR partition table##界面，按shift + f10， 1.进入dos界面。 2.输入 diskpart。 3.输入list disk。 4.输入select disk 。 5.输入clean 就是清除硬盘。 6.转换格式，convert mbr重装系统遇到 Windows cannot be installed to this dis。","categories":[{"name":"Windows","slug":"Windows","permalink":"http://huwj.work/categories/Windows/"}],"tags":[]},{"title":"strcpy与sstrcpy","slug":"strcpy与sstrcpy","date":"2019-12-04T05:06:20.000Z","updated":"2019-12-04T05:22:13.698Z","comments":true,"path":"C/strcpy与sstrcpy/","link":"","permalink":"http://huwj.work/C/strcpy%E4%B8%8Esstrcpy/","excerpt":"在编写C++程序时，不可避免会遇到strcpy()函数和其安全版本strcpy_s()函数，其实之所以会推出_s版本的函数，就是为了使编程更加安全，然而为了保证安全，也就会更容易使我们编写的代码“被报错”。","text":"在编写C++程序时，不可避免会遇到strcpy()函数和其安全版本strcpy_s()函数，其实之所以会推出_s版本的函数，就是为了使编程更加安全，然而为了保证安全，也就会更容易使我们编写的代码“被报错”。 所以这里来简略说一下strcpy()函数和strcpy_s()函数的使用及注意事项。 这道理是为什么呢？ 单单是避免上图中的错误代码4996的情况，可以使用编辑器的选择性提供warning功能，在include语句前面加上下句： #pragma warning( disable : 4996)PS：这里有一个小问题，就是strcpy函数 vs里面强加了一个strcpy_s(),必须在程序的开头加上一句 #define _CRT_SECURE_NO_WARNINGS加完之后，再次运行相同的程序，就可以正常运行了。 那么解决了不使用安全版本的问题，接下来就来说一下使用安全版本的情况。 看下面的代码： int main() { char* str; str = new char[4]; strcpy_s(str, &quot;C++&quot;); return 0; }语法来说没有什么问题，但是因为str的储存空间是使用new临时分配的，所以并不能保证缓冲区大小，点击运行就会出现上述的两种错误了。 这种情况的解决方法其实很简单，那就是不符合2个参数的版本就使用3个参数的版本呗。在两个str之间，加上一个参数，标识长度。 int main() { char* str; str = new char[4]; strcpy_s(str,4, &quot;C++&quot;); return 0; }文章参考：https://blog.csdn.net/leowinbow/article/details/82380252","categories":[{"name":"C++","slug":"C","permalink":"http://huwj.work/categories/C/"}],"tags":[]},{"title":"vue基础","slug":"vue基础","date":"2019-12-04T05:05:46.000Z","updated":"2019-12-04T05:17:38.401Z","comments":true,"path":"Vue/vue基础/","link":"","permalink":"http://huwj.work/Vue/vue%E5%9F%BA%E7%A1%80/","excerpt":"##1基本语法 使用v-html指令直接输出html语法 使用v-bind 属性中的值 例如class href属性 v-if标签内部判断真假 v-model 指令用来在 input、select、textarea、checkbox、radio 等表单控件元素上创建双向数据绑定，根据表单上的值，自动更新绑定的元素的值。 v-on:click=”reverseMessage” v-on 监听事件，并对用户的输入进行响应。(@click=”function”) v-show跟v-if很像 v-if=”ok” 在data中对”ok”的true 或者false","text":"##1基本语法 使用v-html指令直接输出html语法 使用v-bind 属性中的值 例如class href属性 v-if标签内部判断真假 v-model 指令用来在 input、select、textarea、checkbox、radio 等表单控件元素上创建双向数据绑定，根据表单上的值，自动更新绑定的元素的值。 v-on:click=”reverseMessage” v-on 监听事件，并对用户的输入进行响应。(@click=”function”) v-show跟v-if很像 v-if=”ok” 在data中对”ok”的true 或者false","categories":[{"name":"Vue","slug":"Vue","permalink":"http://huwj.work/categories/Vue/"}],"tags":[]},{"title":"随机数","slug":"随机数","date":"2019-12-04T05:05:36.000Z","updated":"2019-12-04T05:22:40.901Z","comments":true,"path":"C/随机数/","link":"","permalink":"http://huwj.work/C/%E9%9A%8F%E6%9C%BA%E6%95%B0/","excerpt":"随机数一直以来都比较麻烦，一般都直接百度使用，这里记录一下，以后就不用百来百去了。 for (i = 0; i &lt; 3; i++) { // 生成实际的随机数 j = rand(); cout &lt;&lt; &quot;随机数： &quot; &lt;&lt; j &lt;&lt; endl; } 该函数返回的数字其实是伪随机数。这意味着它们具有随机数的表现和属性，但实际上并不是随机的，它们实际上是用算法生成的。 cout：41 18467 6334 每次都是这三个数；（因为内部算法的原因 每次都是这三个数）","text":"随机数一直以来都比较麻烦，一般都直接百度使用，这里记录一下，以后就不用百来百去了。 for (i = 0; i &lt; 3; i++) { // 生成实际的随机数 j = rand(); cout &lt;&lt; &quot;随机数： &quot; &lt;&lt; j &lt;&lt; endl; } 该函数返回的数字其实是伪随机数。这意味着它们具有随机数的表现和属性，但实际上并不是随机的，它们实际上是用算法生成的。 cout：41 18467 6334 每次都是这三个数；（因为内部算法的原因 每次都是这三个数） 要在每次运行程序时获得不同的随机数字流，则必须为随机数生成器提供一个种子以开始。在 C++ 中，这是通过调用 srand 函数完成的。 在 rand 被调用之前，srand 函数要先被调用，并且 srand 在整个程序中仅被调用一次。 cout &lt;&lt; &quot;Enter a seed value: &quot;; cin &gt;&gt; seed; // Set the random generator seed before calling rand() for (i = 0; i &lt; 3; i++) { // 生成实际的随机数 j = rand(seed); cout &lt;&lt; &quot;随机数： &quot; &lt;&lt; j &lt;&lt; endl; }这样每次执行的随机数就不一样了（根数输入的seed决定的）实际上，获取种子值的另一个常见做法是调用 time 函数，它是 C++ 标准库的一部分。 srand( (unsigned)time( NULL ) ); /* 生成 10 个随机数 */ for( i = 0; i &lt; 10; i++ ) { // 生成实际的随机数 j= rand(); cout &lt;&lt;&quot;随机数： &quot; &lt;&lt; j &lt;&lt; endl; } return 0; }限制随机数的范围 有时程序需要一个特定范围内的随机数。要将随机数的范围限制在 1 和某个最大值 max 之间的整数，可以使用以下公式： number = rand() % max + 1;例如，要生成 1〜6 的随机数来代表骰子的点数，则可以使用以下语句： dice = rand() % 6 + 1;这里简单介绍一下其工作原理。求余数运算符（％）可以获得整除之后的余数。当使用通过 rand 函数返回的正整数除以6时，余数将是 0〜5 的数字。因为目标是 1〜6 的数字，所以只需要给余数加 1 即可。 这个想法可以扩展到任意范围内的随机数，其通用公式如下： number = (rand()%(maxValue - minValue +1)) + minValue;在上述公式中，minValue 是范围内的最小值，而 maxValue 则是范围内的最大值。例如，要获得** 10〜18** 的随机数，可以使用以下代码给变量 number 赋值： const int MIN_VALUE = 10; const int MAX_VALUE = 18; number = rand() % (MAX_VALUE - MIN_VALUE + 1) + MIN_VALUE;在上述代码中，（MAX_VALUE - MIN_VALUE + 1）的值为 9，这是目标范围内整数的个数。余数运算符（％）返回的值是 0〜8 的数字，再用它加上 MIN_VALUE（也就是 10），即可获得 10〜18 的随机数。","categories":[{"name":"C++","slug":"C","permalink":"http://huwj.work/categories/C/"}],"tags":[]},{"title":"RA代码github地址","slug":"RAdoc","date":"2019-12-04T05:05:16.000Z","updated":"2019-12-06T07:36:55.344Z","comments":true,"path":"Rockwell/RAdoc/","link":"","permalink":"http://huwj.work/Rockwell/RAdoc/","excerpt":"itt/auto_deploy的代码地址点击链接，下载压缩包，解压后里面打开Readme文件，里面有操作教程。","text":"itt/auto_deploy的代码地址点击链接，下载压缩包，解压后里面打开Readme文件，里面有操作教程。 点击下载 电路设计","categories":[{"name":"Rockwell","slug":"Rockwell","permalink":"http://huwj.work/categories/Rockwell/"}],"tags":[]},{"title":"c++对象","slug":"c-对象","date":"2019-12-04T05:05:16.000Z","updated":"2019-12-04T09:15:03.776Z","comments":true,"path":"C/c-对象/","link":"","permalink":"http://huwj.work/C/c-%E5%AF%B9%E8%B1%A1/","excerpt":"C++ 类定义定义一个类，本质上是定义一个数据类型的蓝图。这实际上并没有定义任何数据，但它定义了类的名称意味着什么，也就是说，它定义了类的对象包括了什么，以及可以在这个对象上执行哪些操作。","text":"C++ 类定义定义一个类，本质上是定义一个数据类型的蓝图。这实际上并没有定义任何数据，但它定义了类的名称意味着什么，也就是说，它定义了类的对象包括了什么，以及可以在这个对象上执行哪些操作。 class Line { public: void setLength( double len ); double getLength( void ); Line(); // 这是构造函数 private: double length; };构造函数 Line::Line(void) { cout &lt;&lt; &quot;Object is being created&quot; &lt;&lt; endl; }带参数的构造函数 Line::Line( double len) { cout &lt;&lt; &quot;Object is being created, length = &quot; &lt;&lt; len &lt;&lt; endl; length = len; }使用初始化列表来初始化字段 Line::Line( double len): length(len) { cout &lt;&lt; &quot;Object is being created, length = &quot; &lt;&lt; len &lt;&lt; endl; }上面的语法等价于 Line::Line( double len) { length = len; cout &lt;&lt; &quot;Object is being created, length = &quot; &lt;&lt; len &lt;&lt; endl; }假设有一个类 C，具有多个字段 X、Y、Z 等需要进行初始化，同理地，您可以使用上面的语法，只需要在不同的字段使用逗号进行分隔，如下所示： C::C( double a, double b, double c): X(a), Y(b), Z(c) { .... }类的析构函数 类的析构函数是类的一种特殊的成员函数， 它会在每次删除所创建的对象时执行，也就是对象快消失的时候会触发这个函数，跟构造函数在对象生成时自动触发是一个道理的。 C++ 拷贝构造函数拷贝构造函数是一种特殊的构造函数，在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。通常用于：也就是说一般在复制对象的时候，还有传参的时候（将实参复制给形参）。 通过使用另一个同类型的对象来初始化新创建的对象。 复制对象把它作为参数传递给函数。 复制对象，并从函数返回这个对象。 如果在类中没有定义拷贝构造函数，编译器会自行定义一个。如果类带有指针变量，并有动态内存分配，则它必须有一个拷贝构造函数。拷贝构造函数的最常见形式如下： classname (const classname &amp;obj) { // 构造函数的主体 }C++ 友元函数类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员。尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数。","categories":[{"name":"C++","slug":"C","permalink":"http://huwj.work/categories/C/"}],"tags":[]},{"title":"c++基础","slug":"c-基础","date":"2019-12-04T05:05:04.000Z","updated":"2019-12-04T05:18:15.074Z","comments":true,"path":"C/c-基础/","link":"","permalink":"http://huwj.work/C/c-%E5%9F%BA%E7%A1%80/","excerpt":"extern 存储extern 存储用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 ‘extern’ 时，对于没有初始化的变量，会把变量名指向一个之前定义过的存储位置extern 是用来在另一个文件中声明一个全局变量或函数。（就是将其他文件的变量引用过来）","text":"extern 存储extern 存储用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 ‘extern’ 时，对于没有初始化的变量，会把变量名指向一个之前定义过的存储位置extern 是用来在另一个文件中声明一个全局变量或函数。（就是将其他文件的变量引用过来） mutable 存储thread_local 存储操作运算符：https://www.runoob.com/cplusplus/cpp-operators.html 杂项运算符sizeof 运算符返回变量的大小。例如，sizeof(a) 将返回 4，其中 a 是整数。Condition ? X : Y 条件运算符。如果 Condition 为真 ? 则值为 X : 否则值为 Y。.（点）和 -&gt;（箭头） 成员运算符用于引用类、结构和共用体的成员。 函数参数值传递 指针传递：把参数的地址复制给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。 引用传递：该方法把参数的引用复制给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。 随机数number 赋值： srand( (unsigned)time( NULL ) ); const int MIN_VALUE = 10; const int MAX_VALUE = 18; number = rand() % (MAX_VALUE - MIN_VALUE + 1) + MIN_VALUE; 字符数组取地址这是一个有趣的事情，针对一个而新手c++同学，在面对入下面程序时，肯定特别蒙（至少我是懵逼的） int main() { char greeting[6] = { &apos;H&apos;, &apos;e&apos;, &apos;l&apos;, &apos;l&apos;, &apos;o&apos;, &apos;\\0&apos; }; char *ptr[4]; for (int i = 0; i &lt; MAX; i++) { ptr[i] = &amp;greeting[i]; // 赋值为整数的地址 } for (int i = 0; i &lt; MAX; i++) { cout &lt;&lt; &quot;Value of var[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot;; cout &lt;&lt; ptr[i] &lt;&lt; endl; } return 0; } 程序输出 Value of var[0] = Hello Value of var[1] = ello Value of var[2] = llo Value of var[3] = lo讲道理应该输出数组的地址啊 Value of var[0] = 0118F994 Value of var[1] = 0118F995 Value of var[2] = 0118F996 Value of var[3] = 0118F997其实是cout在作怪，这里面cout默认把”cout &lt;&lt; 字符型指针”这种输出格式安排给输出字符串了，就是说它被编译器解释为从指针开始一个接一个地输出内存单元里的字符，直到遇到’\\0’时为止。要想输出地址你强制成别的类型就可以了： 如cout &lt;&lt; (void *)pts[i] &lt;&lt; endl;就可以Struct数组允许定义可存储相同类型数据项的变量，但是结构是一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项。 struct Books { char title[50]; char author[50]; char subject[100]; int book_id; } Book1; //或者 Book Book1，Book2；访问结构成员为了访问结构的成员，我们使用成员访问运算符（.）。 指向结构的指针定义指向结构的指针，方式与定义指向其他类型变量的指针相似，如下所示： struct Books *struct_pointer; struct_pointer = &amp;Book1; //为了使用指向该结构的指针访问结构的成员，必须使用 -&gt; 运算符 struct_pointer-&gt;title;typedef 关键字typedef struct Books { char title[50]; char author[50]; char subject[100]; int book_id; }Books;类成员函数可以定义在类定义内部，或者单独使用范围解析运算符 :: 来定义。 class Box { public: double length; // 长度 double breadth; // 宽度 double height; // 高度 double getVolume(void) { return length * breadth * height; } };也可以在类的外部使用范围解析运算符 :: 定义该函数，如下所示： double Box::getVolume(void) { return length * breadth * height; }C++ 类访问修饰符简单的来说就是：public 随便访问private 不能随便访问 get set函数 不可以被派生类访问protected 不能随便访问 get set 派生类可以访问 有public, protected, private三种继承方式，它们相应地改变了基类成员的访问属性。 1.public 继承：基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：public, protected, private 2.protected 继承：基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：protected, protected, private 3.private 继承：基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：private, private, private 但无论哪种继承方式，上面两点都没有改变： 1.private 成员只能被本类成员（类内）和友元访问，不能被派生类访问； 2.protected 成员可以被派生类访问。 C++ 类构造函数 &amp; 析构 ##函数类的构造函数是类的一种特殊的成员函数，它会在每次创建类的新对象时执行。 // 有参数 Line::Line( double len) { cout &lt;&lt; &quot;Object is being created, length = &quot; &lt;&lt; len &lt;&lt; endl; length = len; } //无参数 Line::Line(void) { cout &lt;&lt; &quot;Object is being created&quot; &lt;&lt; endl; }使用初始化列表来初始化字段Line::Line( double len): length(len) { cout &lt;&lt; &quot;Object is being created, length = &quot; &lt;&lt; len &lt;&lt; endl; } //等效于 Line::Line( double len) { length = len; cout &lt;&lt; &quot;Object is being created, length = &quot; &lt;&lt; len &lt;&lt; endl; } /*假设有一个类 C，具有多个字段 X、Y、Z 等需要进行初始化，同理地，您可以使用上面的语法， 只需要在不同的字段使用逗号进行分隔，如下所示：*/ C::C( double a, double b, double c): X(a), Y(b), Z(c) { .... }类的析构函数类的析构函数是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行。析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号（~）作为前缀，它不会返回任何值，也不能带有任何参数。析构函数有助于在 跳出程序（比如关闭文件、释放内存等）前释放资源 。","categories":[{"name":"C++","slug":"C","permalink":"http://huwj.work/categories/C/"}],"tags":[]},{"title":"置顶","slug":"置顶","date":"2019-12-04T04:58:48.000Z","updated":"2019-12-06T05:26:17.436Z","comments":true,"path":"uncategorized/置顶/","link":"","permalink":"http://huwj.work/uncategorized/%E7%BD%AE%E9%A1%B6/","excerpt":"Markdown 语法是对纯文本格式的强化，能使文本显示得更清晰、有条理。但它依旧算是简单的文本，很容易修改和扩展，常用于快速写作中。也正是因为MarkDown更注重简洁，所以对于图文混排，一些特定效果等功能进行了弱化，比如想设置图文并列，图片墙等时，纯MarkDown语法就无法实现了。 还好，Markdown 格式的兼容扩展性颇佳，使之能快速转换为各种互联网上的常用格式，比如 HTML、Word、PDF 等。","text":"Markdown 语法是对纯文本格式的强化，能使文本显示得更清晰、有条理。但它依旧算是简单的文本，很容易修改和扩展，常用于快速写作中。也正是因为MarkDown更注重简洁，所以对于图文混排，一些特定效果等功能进行了弱化，比如想设置图文并列，图片墙等时，纯MarkDown语法就无法实现了。 还好，Markdown 格式的兼容扩展性颇佳，使之能快速转换为各种互联网上的常用格式，比如 HTML、Word、PDF 等。 所以要实现图文混排，我们可以使用HTML语法来完成，比如完成一个图片并列排放效果，就可以在MarkDown文档中直接写入如下示例代码实现：————————————————版权声明：本文为CSDN博主「csdjia11」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/csdjia11/article/details/91896116","categories":[],"tags":[]},{"title":"工作点滴","slug":"work1","date":"2018-08-04T05:05:27.000Z","updated":"2019-12-04T05:11:54.865Z","comments":true,"path":"点滴生活/work1/","link":"","permalink":"http://huwj.work/%E7%82%B9%E6%BB%B4%E7%94%9F%E6%B4%BB/work1/","excerpt":"一、有”同理心”1.1、什么叫”同理心”? 说复杂点儿，同理心就是站在当事人的角度和位置上，客观地理解当事人的内心感受，且把这种理解传达给当事人的一种沟通交流方式。 说简单点儿，同理心就是“己所不欲，勿施于人”。将心比心，也就是设身处地去感受、去体谅他人。 说白了，同理心就是“情商”。","text":"一、有”同理心”1.1、什么叫”同理心”? 说复杂点儿，同理心就是站在当事人的角度和位置上，客观地理解当事人的内心感受，且把这种理解传达给当事人的一种沟通交流方式。 说简单点儿，同理心就是“己所不欲，勿施于人”。将心比心，也就是设身处地去感受、去体谅他人。 说白了，同理心就是“情商”。 具体点说： 同理心就是，领导交办一项工作，你要读懂他的目的、看清他的用意。我经常遇到这样的情况：给团队成员安排工作时，一再询问“我说明白了吗”“有 没有问题”，再三确认后，提交上来的东西仍然答非所问。所以我在接受任务时，总会向领导确认：你想要的是什么?你的目的是什么?了解这个以后，就可以站在 他的角度，有效的帮他解决问题。 同理心就是，在激励员工时，点准他们的“兴奋点”，不揭“伤疤”。每个人都有认真工作的理由，家庭富裕的为了证明自己的能力，家境贫寒的为了改 善自己的生活，吊儿郎当的爱面子怕丢工作。了解不同人的不同心理需求，才能调动大家的积极性。若是不问青红皂白，拿着鞭子大喊加油，只能是徒劳无功。 同理心就是，在与他人合作时，了解对方的需求和心理，潜移默化的说服对方，双方为了同一个目标而努力。想用强势压服别人，通常不好使。 二、听话，出活 “什么叫好员工啊，好员工特简单，就四个字：听话、出活”。这是至理名言。 什么叫“听话”?有句老话叫“干活不由东，累死也无功”，谁是“东”啊?你的直属领导就是“东”，大部分时候，听他的话准没错儿。 有朋友说：我有能力，我比领导水平高，我就不听领导的!咱先不说到底谁水平高——既然他能当你领导，肯定有比你强的地方——咱就说水平和能力这事儿，什么叫“有能力”啊?领导用你，你就有能力。不用你，甭管您有再大的能力，都是白费。 根据我的经验，一般来说，领导都比你水平高，起码在一点上是这样：他比你信息更全面、判断的更准确。因为领导更容易接触到更高层，更了解更高层的意图，他知道的你不知道，你在自己的角度上认为“这么做对”，但领导在更高的层面，并不一定这么看。 还有朋友说我领导就是瞎指挥，明摆着不对，我干嘛要听他的?这是另外一个问题，咱们最后一条会谈到，如果你觉得现在的环境无法进步，就可以考虑离职了。 什么叫“出活”?就是领导给你的工作，你得按时完成并且汇报总结。如果这个工作要持续较长时间，那么你需要阶段性的给领导反馈。我们经常犯一个错误，领导安排的工作，他不问你也不说，黑不提白不提这事儿就算过去了。 过去了?哪儿那么容易啊!领导都记着呢，你等他问你的时候——“诶小陈，上次安排你做的那事儿怎么样了?”——他就已经在心里给你写上了标签：“不靠谱”。 一个“不靠谱”需要用十个“靠谱”来扭转，两个“不靠谱”就很难转变印象，三个“不靠谱”你就没有机会了。 三、要想人前显贵，必须背地里受罪 在公司里上班，大家的智商都差不多，谁也不比谁强多少，拼的都是努力和用心的程度。你下功夫了，就比别人做得好。哦，本来就不比别人聪明，别人下班你也下班、别人玩儿你也玩儿、别人搞对象你也泡马子，你凭什么比别人干得好? “要想人前显贵，必须背地里受罪”的道理并不难懂。就是真到受苦的时候就含糊了，有的人会说，我年纪轻轻的为什么不好好享受生活啊?这种想法很 普遍，这本是一个价值观的问题，没什么可说的，一个人想怎么生活都对。但是有一些朋友是在追求理想和享受生活中纠结的，和这些朋友，是可以聊的。 马云曾经说过：我们追求的应是人生的大平衡，而不是一时一日的小平衡(大意如此)。新东方也有一句话说：怕吃苦吃苦一辈子，不怕苦吃苦半辈子。两句话大意相同，值得深思。 一件工作，你用心想了做了，领导一看就知道，你想糊弄，也是一看就知道，这个没侥幸。领导在判断这个问题的时候，标准很简单：我想到的，你都没想到，肯定没用心;我想到的，你想到了一部分，用心不够;我没想到的，你想到了，这是用心了——这就是“超预期”(“出活”还有一层含义，就是“超预期”。)。如果你每次都能给你的老板一个超预期的 结果，那你无疑就是一个好员工。 四、能忍多大事儿，就能成多大事儿 在工作上想受到领导的赏识和重用，除了要有过硬的工作能力外，更重要的，要有足够的涵养(抗压力或者回血能力)。能受多大委屈，才能成多大事儿，这是一定的。为了考察你的“抗压力”，领导有时会故意试你，你可一定要经得住考验。 五、总躲着领导，你就危险了 不少人躲着领导，尽量少跟领导说话、绕着领导走。因为跟领导近了事儿就多，不跟领导多接触，事儿少，多清闲。这是“一叶障目，不见泰山”。 如果你想在工作上取得一些成绩，我建议还是应该主动的多和领导沟通。领导在平时开会时说的多是大面儿上的话，真话、有用的话、有价值的话不一定说。这并不是他不想说，而是没机会说。 有心的员工会随时抽时间和领导沟通、增加私人交流的机会：一起吃饭、一起抽烟、一起上下班、甚至一起打球K歌……通过这样的机会，你可以了解领导对于你的看法、对于工作的观点，这些都有益于你调整自己的工作的方式。 有朋友担心这样做会引起领导反感，其实完全不会，领导们多是孤独的，如果他发现有一个员工虚心向他请教、积极分享工作的思考，他是非常高兴的。 有朋友说，我不想那么累，我就想混混日子。即便是这样，你最好也主动和领导沟通、主动汇报。你追着他，你是主动的一方，其实你不累;等到他追你的时候，你就被动了，最终就累死了。 老罗曾经讲过一个故事，说你进入单位，见到老板就低头过去、不理他，他当然也不理你。等到年终考核、或者裁员的时候，老板隐约记得有你这么个人，但不知道你的名字、更不知道你做了什么。老板会想：这是你的错，不是我的错。不开除你开除谁? 老板也是人，大家用人类的方式沟通，一切会变得简单很多。 六、帮助别人千万别吝啬 马云曾经说，成功就是成就自己帮助别人。这话没错。 如果你在一家公司工作，你发现你的工作不用任何人协助就能自己独立完成，那你多半是个打杂的。相反，你的工作需要越多人协作，就越复杂、越高级。在实际工作中我发现，我处在一个协作关系网中，如果没有别人的帮助，我就无法工作下去。 当你正在忙于某项工作时，有同事来向你“求助”，很多时候我们会很直接、甚至粗暴的拒绝，殊不知这样做正在给你今后的工作种下麻烦的种子。风水 轮流转，在一家公司里，大家的工作互相交叉的几率很大，说不定你会用上谁，这些人脉关系需要平时去维护。今天你帮助了人家，说不定明天对方就会成为你的救 命稻草，这非常可能。 有一天我正在疲于应付一个项目总结，这时有个其他部门的同事来找我聊合作的事儿，我并不认识他，我耐心的和他介绍了情况，并且真的形成了几次愉快的合作，半年后，我的晋升答辩会上，我发现他是我的答辩委员…… 七、目标再目标，量化再量化 没有目标的，都不叫工作;没有量化的，都不叫目标。 在接受一项工作时，先问目标是什么;在布置一项工作时，先交代目标是什么。这个不说清楚，都是扯淡。 不想成为蒙着眼睛拉磨的驴?那么除了清楚的知道自己的目标外，还得知道你的部门、你的公司的目标，最关键的，你需要知道，你的工作在总体目标中处在什么地位、扮演什么角色。如果你发现，你工作的目标和总体目标关系很小、甚至没有关系，那么你就很容易被拿掉。 辞退员工，或给员工绩效打分“不合格”是很令人头疼的，但其实这事儿并不难。关键就在于事先和每个员工一起制定量化的工作目标，并且随时提醒员 工，他的工作是否达到了要求。没有达到量化指标，辞退或“不合格”是令所当然事儿，在数据面前，再矫情的人也无话可说。相反，如果谈感觉、聊希望，这事儿 就没法办了。 八、找到解决问题的办法是我的义务 领导安排的工作，不能说“我做不了”、“我做不到”。 公司请我们来工作，是为了解决问题的，如果不能解决问题，我们就没有价值。工作推进中遇到困难，无法继续进行，这是很正常的事儿，我们需要做的是主动寻找答案和办法，哪怕你的办法不妥，那么就去问，但无论如何不能对你的领导说，我不会。 前天，我在公司里听见隔壁团队的领导安排同事定一个会议室，有公司工作经验的人都知道，会议室是很难订到的，弄不好还需要“托关系，走后门”。这个小同学可能是没有订到，于是和他的领导说“我没订到”，他的领导直接就急了，说：“那怎么办?需要我来订吗?” 这位领导发火是有道理的，这位小同学在发现自己订不到会议室后，应该做的是自己想办法解决问题——最简单的就是向老同事咨询。 解决问题的能力是员工最关键的能力，没有之一。在工作中遇到困难特别正常，在这时，我们有一项义务，就是找到解决问题的办法。 九、尽量不说“不是我，我没有” 绝大多数人在面对批评的时候，本能反应都是推卸责任，此时的口头禅就是“不是我”、“没有我”。我总觉得，很多时候，越成熟的人，就越少用本能反应面对问题，因为他们有更强的自控力。 尽量不说“不是我”、“没有我”这样的话，因为这些话毫无作用，领导听惯了这样的推卸之词，丝毫不会为之所动。此时如果能够主动承担责任，反而体现了一种担 当。即便真是被冤枉了，当场辩解往往也不是最明智的选择，可以先保持沉默，私下找机会和领导进行沟通。这个详见第三条。 十、“言多必失”死得惨 在公司里，少说闲话，不说是非话，不做是非人。 你就相信一点：你说的每句话，你的老板都会知道。好话可能不一定，坏话则是一定的。 还是做个正直的人吧，这样最简单，也受益最大。正直人的原则是：批评当面说，赞美背后讲。 十一、知道什么时候离开 好多同事和朋友和我聊过离职的话题，我对朋友们的建议是，如果你因为觉得工作不爽，那就别离职，因为甭管到哪里，都会不爽：老板不喜欢、同事不可爱、工作太劳累、关系太复杂……我以我在多家大公司工作的经历担保：几乎所有我工作过的公司，令人不爽的事儿都是一样的。 那么什么时候离开呢?我想，有两种情况： 1、在这家公司，你已经没有上升的空间、无法学习到更多的东西了; 2、在这家公司，你已学到足够的知识，可以在新领域或新平台上一展身手了。 本文转载自：http://news.cnblogs.com/n/213563/","categories":[{"name":"点滴生活","slug":"点滴生活","permalink":"http://huwj.work/categories/%E7%82%B9%E6%BB%B4%E7%94%9F%E6%B4%BB/"}],"tags":[]}]}