<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>String/StringBuilder/StringBuffer | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="1. String,StringBuffer与StringBuilder的区别String：存储在常量池中；是不可变的字符序列，任何对String值的改变都会引发新的String对象的生成，因此执行字符串值改变的操作时效率很低，此时一般选择StingBuffer或者StringBuilder；支持并发操作，是线程安全的 ； StringBuffer 和 StringBuilder都是可变字符串；n">
<meta property="og:type" content="article">
<meta property="og:title" content="String&#x2F;StringBuilder&#x2F;StringBuffer">
<meta property="og:url" content="http:&#x2F;&#x2F;huwj.work&#x2F;java&#x2F;String-StringBuilder-StringBuffer">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="1. String,StringBuffer与StringBuilder的区别String：存储在常量池中；是不可变的字符序列，任何对String值的改变都会引发新的String对象的生成，因此执行字符串值改变的操作时效率很低，此时一般选择StingBuffer或者StringBuilder；支持并发操作，是线程安全的 ； StringBuffer 和 StringBuilder都是可变字符串；n">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2018-10-09T12:32:20.000Z">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://huwj.work"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-String-StringBuilder-StringBuffer" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/java/String-StringBuilder-StringBuffer" class="article-date">
  <time datetime="2018-10-09T12:15:06.000Z" itemprop="datePublished">2018-10-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      String/StringBuilder/StringBuffer
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-String-StringBuffer与StringBuilder的区别"><a href="#1-String-StringBuffer与StringBuilder的区别" class="headerlink" title="1. String,StringBuffer与StringBuilder的区别"></a>1. String,StringBuffer与StringBuilder的区别</h2><p>String：存储在常量池中；是不可变的字符序列，任何对String值的改变都会引发新的String对象的生成，因此执行字符串值改变的操作时效率很低，此时一般选择StingBuffer或者StringBuilder；支持并发操作，是线程安全的 ；</p>
<p>StringBuffer 和 StringBuilder都是可变字符串；new出的对象存储在堆中；主要区别在于：</p>
<p>StringBuffer：是线程安全的，因此牺牲了一定的效率来维护同步锁；</p>
<p>StringBuilder：线程不安全，效率最高；</p>
<p>StringBuilder可以操作StringBuffer，但是StringBuffer不可以操作StringBuilder，这也是线程的原因；</p>
<p>总结：效率：StringBuilder&gt;StringBuffer&gt;String；所以，如果这是考虑单线程程序的话，用StringBuilder，如果涉及到多线程的，考虑到线程安全问题只能用StringBuffer。</p>
<h2 id="2-String"><a href="#2-String" class="headerlink" title="2. String"></a>2. String</h2><p>String 类型和 StringBuffer 类型的主要性能区别其实在于 String 是不可变的对象, 因此在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要用 String ，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后， JVM 的 GC 就会开始工作，那速度是一定会相当慢的。</p>
<p>而如果是使用 StringBuffer 类则结果就不一样了，每次结果都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，再改变对象引用。所以在一般情况下我们推荐使用 StringBuffer ，特别是字符串对象经常改变的情况下。而在某些特别情况下， String 对象的字符串拼接其实是被 JVM 解释成了 StringBuffer 对象的拼接，所以这些时候 String 对象的速度并不会比 StringBuffer 对象慢，而特别是以下的字符串对象生成中， String 效率是远要比 StringBuffer 快的：</p>
<pre><code>String S1 = “This is only a” + “ simple” + “ test”;
StringBuffer Sb = new StringBuilder(“This is only a”).append(“ simple”).append(“ test”);</code></pre><p>你会很惊讶的发现，生成 String S1 对象的速度简直太快了，而这个时候 StringBuffer 居然速度上根本一点都不占优势。其实这是 JVM 的一个把戏，在 JVM 眼里，这个</p>
<p><code>String S1 = “This is only a” + “ simple” + “test”;</code> <br><br>其实就是：<br><code>String S1 = “This is only a simple test”;</code><br>所以当然不需要太多的时间了。但大家这里要注意的是，如果你的字符串是来自另外的 String 对象的话，速度就没那么快了，譬如：</p>
<pre><code>String S2 = “This is only a”;
String S3 = “ simple”;
String S4 = “ test”;
String S1 = S2 +S3 + S4;</code></pre><p>这时候 JVM 会规规矩矩的按照原来的方式去做</p>
<p><strong>在大部分情况下 StringBuffer &gt; String</strong></p>
<h2 id="3-StringBuffer"><a href="#3-StringBuffer" class="headerlink" title="3. StringBuffer"></a>3. StringBuffer</h2><p>Java.lang.StringBuffer线程安全的可变字符序列。一个类似于 String 的字符串缓冲区，但不能修改。虽然在任意时间点上它都包含某种特定的字符序列，但通过某些方法调用可以改变该序列的长度和内容。可将字符串缓冲区安全地用于多个线程。可以在必要时对这些方法进行同步，因此任意特定实例上的所有操作就好像是以串行顺序发生的，该顺序与所涉及的每个线程进行的方法调用顺序一致。<br>StringBuffer 上的主要操作是 append 和 insert 方法，可重载这些方法，以接受任意类型的数据。每个方法都能有效地将给定的数据转换成字符串，然后将该字符串的字符追加或插入到字符串缓冲区中。append 方法始终将这些字符添加到缓冲区的末端；而 insert 方法则在指定的点添加字符。</p>
<pre><code>例如，如果 z 引用一个当前内容是“start”的字符串缓冲区对象，
则此方法调用 z.append(&quot;le&quot;) 会使字符串缓冲区包含“startle”，
而 z.insert(4, &quot;le&quot;) 将更改字符串缓冲区，使之包含“starlet”。
在大部分情况下 StringBuilder &gt; StringBuffer</code></pre><h2 id="4-StringBuilder"><a href="#4-StringBuilder" class="headerlink" title="4. StringBuilder"></a>4. StringBuilder</h2><p>java.lang.StringBuilder一个可变的字符序列是5.0新增的。此类提供一个与 StringBuffer 兼容的 API，但不保证同步。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。如果可能，建议优先采用该类，因为在大多数实现中，它比 StringBuffer 要快。两者的方法基本相同。</p>
<h2 id="5-StringBuffer的主要方法介绍"><a href="#5-StringBuffer的主要方法介绍" class="headerlink" title="5. StringBuffer的主要方法介绍"></a>5. StringBuffer的主要方法介绍</h2><p>（由于StringBuffer和StringBuilder在使用上几乎一样，所以只写一个，以下部分内容网络各处收集，不再标注出处）</p>
<pre><code>StringBuffer s = new StringBuffer();</code></pre><p>这样初始化出的StringBuffer对象是一个空的对象，</p>
<pre><code>StringBuffer sb1=new StringBuffer(512);</code></pre><p>分配了长度512字节的字符缓冲区。 </p>
<pre><code>StringBuffer sb2=new StringBuffer(“how are you?”)</code></pre><p>创建带有内容的StringBuffer对象，在字符缓冲区中存放字符串</p>
<p><code>“how are you?”</code></p>
<h2 id="a、append方法"><a href="#a、append方法" class="headerlink" title="a、append方法"></a>a、append方法</h2><pre><code>public StringBuffer append(boolean b)</code></pre><p>该方法的作用是追加内容到当前StringBuffer对象的末尾，类似于字符串的连接，调用该方法以后，StringBuffer对象的内容也发生改 变，例如：</p>
<pre><code>StringBuffer sb = new StringBuffer(“abc”);
sb.append(true);</code></pre><p>则对象sb的值将变成”abctrue”</p>
<p>使用该方法进行字符串的连接，将比String更加节约内容，经常应用于数据库SQL语句的连接。</p>
<h2 id="b、deleteCharAt方法"><a href="#b、deleteCharAt方法" class="headerlink" title="b、deleteCharAt方法"></a>b、deleteCharAt方法</h2><pre><code>public StringBuffer deleteCharAt(int index)</code></pre><p>该方法的作用是删除指定位置的字符，然后将剩余的内容形成新的字符串。例如：</p>
<pre><code>StringBuffer sb = new StringBuffer(“KMing”);
sb. deleteCharAt(1);</code></pre><p>该代码的作用删除字符串对象sb中索引值为1的字符，也就是删除第二个字符，剩余的内容组成一个新的字符串。所以对象sb的值变 为”King”。<br>还存在一个功能类似的delete方法：</p>
<pre><code>`public StringBuffer delete(int start,int end)`</code></pre><p>该方法的作用是删除指定区间以内的所有字符，包含start，不包含end索引值的区间。例如：</p>
<pre><code>StringBuffer sb = new StringBuffer(“TestString”);
sb. delete (1,4);</code></pre><p>该代码的作用是删除索引值1(包括)到索引值4(不包括)之间的所有字符，剩余的字符形成新的字符串。则对象sb的值是”TString”。 前包括后不包括方法。</p>
<h2 id="c、insert方法"><a href="#c、insert方法" class="headerlink" title="c、insert方法"></a>c、insert方法</h2><pre><code>public StringBuffer insert(int offset, boolean b),</code></pre><p>该方法的作用是在StringBuffer对象中插入内容，然后形成新的字符串。例如：</p>
<pre><code>`StringBuffer sb = new StringBuffer(“TestString”);
 sb.insert(4,false);`</code></pre><p>该示例代码的作用是在对象sb的索引值4的位置插入false值，形成新的字符串，则执行以后对象sb的值是”TestfalseString”。 </p>
<h2 id="d、reverse方法"><a href="#d、reverse方法" class="headerlink" title="d、reverse方法"></a>d、reverse方法</h2><pre><code>public StringBuffer reverse()</code></pre><p>该方法的作用是将StringBuffer对象中的内容反转，然后形成新的字符串。例如：</p>
<pre><code>`StringBuffer sb = new StringBuffer(“abc”);
 sb.reverse();`</code></pre><p>经过反转以后，对象sb中的内容将变为”cba”。 </p>
<h2 id="e、setCharAt方法"><a href="#e、setCharAt方法" class="headerlink" title="e、setCharAt方法"></a>e、setCharAt方法</h2><pre><code>public void setCharAt(int index, char ch)</code></pre><p>该方法的作用是修改对象中索引值为index位置的字符为新的字符ch。例如：</p>
<pre><code>`StringBuffer sb = new StringBuffer(“abc”);
sb.setCharAt(1,’D’);`</code></pre><p>则对象sb的值将变成”aDc”。 </p>
<h2 id="f、trimToSize方法"><a href="#f、trimToSize方法" class="headerlink" title="f、trimToSize方法"></a>f、trimToSize方法</h2><p>public void trimToSize()<br>该方法的作用是将StringBuffer对象的中存储空间缩小到和字符串长度一样的长度，减少空间的浪费，和String的trim()是一样的作用，不在举例。</p>
<h2 id="g、length方法"><a href="#g、length方法" class="headerlink" title="g、length方法"></a>g、length方法</h2><p>该方法的作用是获取字符串长度 ，不用再说了吧。</p>
<h2 id="h、setlength方法"><a href="#h、setlength方法" class="headerlink" title="h、setlength方法"></a>h、setlength方法</h2><p>该方法的作用是设置字符串缓冲区大小。</p>
<pre><code>`StringBuffer sb=new StringBuffer();
sb.setlength(100);`</code></pre><p>如果用小于当前字符串长度的值调用setlength()方法，则新长度后面的字符将丢失。 </p>
<h2 id="i、sb-capacity方法"><a href="#i、sb-capacity方法" class="headerlink" title="i、sb.capacity方法"></a>i、sb.capacity方法</h2><p>该方法的作用是获取字符串的容量。</p>
<pre><code>`StringBuffer sb=new StringBuffer(“string”);
int i=sb.capacity(); `</code></pre><h2 id="j、ensureCapacity方法"><a href="#j、ensureCapacity方法" class="headerlink" title="j、ensureCapacity方法"></a>j、ensureCapacity方法</h2><p>该方法的作用是重新设置字符串容量的大小。</p>
<pre><code>`StringBuffer sb=new StringBuffer();
sb.ensureCapacity(32); //预先设置sb的容量为32 `</code></pre><h2 id="k、getChars方法"><a href="#k、getChars方法" class="headerlink" title="k、getChars方法"></a>k、getChars方法</h2><p>该方法的作用是将字符串的子字符串复制给数组。</p>
<pre><code>`getChars(int start,int end,char chars[],int charStart); 

StringBuffer sb = new StringBuffer(&quot;I love You&quot;);
int begin = 0;
int end = 5;
//注意ch字符数组的长度一定要大于等于begin到end之间字符的长度
//小于的话会报ArrayIndexOutOfBoundsException
//如果大于的话，大于的字符会以空格补齐
char[] ch  = new char[end-begin];
sb.getChars(begin, end, ch, 0);
System.out.println(ch);`</code></pre><p>结果：I lov</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://huwj.work/java/String-StringBuilder-StringBuffer" data-id="ck3gl3nq30003vkez3siehz9j" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/java/this-super" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          this/super
        
      </div>
    </a>
  
  
    <a href="/office/word%E5%8A%A0%E9%A1%B5%E7%A0%81" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">word加页码</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/AR/">AR</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/HTML/">HTML</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/book/">book</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/css/">css</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/js/">js</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/office/">office</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/spring/">spring</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/">云计算</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8D%9A%E5%AE%A2/">博客</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%82%B9%E6%BB%B4%E7%94%9F%E6%B4%BB/">点滴生活</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/">神经网络</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/%E7%AE%97%E6%B3%95/%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97%E4%B9%8B%E5%92%8C">最大连续子序列之和</a>
          </li>
        
          <li>
            <a href="/spring/spring-aop-1">spring_aop_代码实现</a>
          </li>
        
          <li>
            <a href="/spring/spring-aop">spring_aop</a>
          </li>
        
          <li>
            <a href="/spring/spring1">spring_DI</a>
          </li>
        
          <li>
            <a href="/java/leetcode">leetcode</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>