<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http:&#x2F;&#x2F;huwj.work&#x2F;index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://huwj.work"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-最大连续子序列之和" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/%E7%AE%97%E6%B3%95/%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97%E4%B9%8B%E5%92%8C" class="article-date">
  <time datetime="2018-11-27T08:51:41.000Z" itemprop="datePublished">2018-11-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/%E7%AE%97%E6%B3%95/%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97%E4%B9%8B%E5%92%8C">最大连续子序列之和</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://huwj.work/%E7%AE%97%E6%B3%95/%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97%E4%B9%8B%E5%92%8C" data-id="ck3gl3nu9001zvkez7hmzbuq0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-spring-aop-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/spring/spring-aop-1" class="article-date">
  <time datetime="2018-11-19T08:01:44.000Z" itemprop="datePublished">2018-11-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/spring/">spring</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/spring/spring-aop-1">spring_aop_代码实现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="切面创建的三种方式："><a href="#切面创建的三种方式：" class="headerlink" title="切面创建的三种方式："></a><strong>切面创建的三种方式：</strong></h3><p><strong>通过切点来选择连接点：</strong></p>
<p><strong>@AspectJ：</strong>@AspectJ 是一种使用 Java 注解来实现 AOP 的编码风格.</p>
<p><strong>通过XML方式:</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://huwj.work/spring/spring-aop-1" data-id="ck3gl3nsz0013vkez7us322dl" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-spring-aop" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/spring/spring-aop" class="article-date">
  <time datetime="2018-11-19T07:10:23.000Z" itemprop="datePublished">2018-11-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/spring/">spring</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/spring/spring-aop">spring_aop</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="AOP："><a href="#AOP：" class="headerlink" title="AOP："></a>AOP：</h2><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h3 id="名词解释："><a href="#名词解释：" class="headerlink" title="名词解释："></a>名词解释：</h3><p><strong>advice：</strong>具体做什么工作，一般为一段java代码，比如拦截器，由 aspect 添加到特定的 join point(即满足 point cut 规则的 join point) 的一段代码。许多 AOP框架, 包括 Spring AOP, 会将 advice 模拟为一个拦截器(interceptor), 并且在 join point 上维护多个 advice, 进行层层拦截。<br><br><strong>例如</strong> HTTP 鉴权的实现, 我们可以为每个使用 RequestMapping 标注的方法织入 advice, 当 HTTP 请求到来时, 首先进入到 advice 代码中, 在这里我们可以分析这个 HTTP 请求是否有相应的权限, 如果有, 则执行 Controller, 如果没有, 则抛出异常. 这里的 advice 就扮演着鉴权拦截器的角色了.<br><br><strong>join point:</strong>所有方法的执行点，或者是异常的处理。<br><br><strong>point cut</strong>一个描述信息，在切面的过程中，并不是所有的join point都是可以进行advice的，只有一部分被选中的才可以，那么被选中的方法或者异常就死point cut。<br></p>
<blockquote>
<p>在 Spring 中, 所有的方法都可以认为是 joinpoint, 但是我们并不希望在所有的方法上都添加 Advice, 而 pointcut 的作用就是提供一组规则(使用 AspectJ pointcut expression language 来描述) 来匹配joinpoint, 给满足规则的 joinpoint 添加 Advice.</p>
</blockquote>
<p><strong>关于join point 和 point cut 的区别</strong></p>
<blockquote>
</blockquote>
<p>在 Spring AOP 中, 所有的方法执行都是 join point. 而 point cut 是一个描述信息, 它修饰的是 join point, 通过 point cut, 我们就可以确定哪些 join point 可以被织入 Advice. 因此 join point 和 point cut 本质上就是两个不同纬度上的东西.<br>advice 是在 join point 上执行的, 而 point cut 规定了哪些 join point 可以执行哪些 advice</p>
<p><strong>aspect：</strong>aspect 是 point cut 与 advice 的组合。<br><br><strong>advice 的类型:</strong><br><br><strong>before advice</strong> 在 join point 前被执行的 advice. 虽然 before advice 是在 join point 前被执行, 但是它并不能够阻止 join point 的执行, 除非发生了异常(即我们在 before advice 代码中, 不能人为地决定是否继续执行 join point 中的代码)</p>
<p><strong>after return advice</strong>, 在一个 join point 正常返回后执行的 advice</p>
<p><strong>after throwing advice</strong>, 当一个 join point 抛出异常后执行的 advice</p>
<p><strong>after(final) advice</strong>, 无论一个 join point 是正常退出还是发生了异常, 都会被执行的 advice.</p>
<p><strong>around advice</strong>, 在 join point 前和 joint point 退出后都执行的 advice. 这个是最常用的 advice.</p>
<p><strong>AOP proxy</strong>：一个类被 AOP 织入 advice, 就会产生一个结果类, 它是融合了原类和增强逻辑的代理类.<br>在 Spring AOP 中, 一个 AOP 代理是一个 JDK 动态代理对象或 CGLIB 代理对象.</p>
<p><strong>introduction：</strong>为一个类型添加额外的方法或字段. Spring AOP 允许我们为 目标对象 引入新的接口(和对应的实现). 例如我们可以使用 introduction 来为一个 bean 实现 IsModified 接口, 并以此来简化 caching 的实现.</p>
<p><strong>Target：</strong>织入 advice 的目标对象. 目标对象也被称为 <strong>advised object</strong>.<br>因为 Spring AOP 使用运行时代理的方式来实现 aspect, 因此 adviced object 总是一个代理对象(proxied object)<br>注意, adviced object 指的不是原来的类, 而是织入 advice 后所产生的代理类.</p>
<p><strong>Weaving：</strong>将 aspect 和其他对象连接起来, 并创建 adviced object 的过程.<br>根据不同的实现技术, AOP织入有三种方式:</p>
<p>1_编译器织入, 这要求有特殊的Java编译器.</p>
<p>2_类装载期织入, 这需要有特殊的类装载器.</p>
<p>3_动态代理织入, 在运行期为目标类添加增强(Advice)生成子类的方式.<br>Spring 采用动态代理织入, 而AspectJ采用编译器织入和类装载期织入.</p>
<p>下面讲一个小故事；其实spring in action上也有一个，不过还是喜欢这位兄dei的故事，简单易懂。</p>
<p><strong>彻底理解 aspect, join point, point cut, advice</strong></p>
<p>让我们来假设一下, 从前有一个叫爪哇的小县城, 在一个月黑风高的晚上, 这个县城中发生了命案. 作案的凶手十分狡猾, 现场没有留下什么有价值的线索. 不过万幸的是, 刚从隔壁回来的老王恰好在这时候无意中发现了凶手行凶的过程, 但是由于天色已晚, 加上凶手蒙着面, 老王并没有看清凶手的面目, 只知道凶手是个男性, 身高约七尺五寸. 爪哇县的县令根据老王的描述, 对守门的士兵下命令说: 凡是发现有身高七尺五寸的男性, 都要抓过来审问. 士兵当然不敢违背县令的命令, 只好把进出城的所有符合条件的人都抓了起来.</p>
<p>来让我们看一下上面的一个小故事和 AOP 到底有什么对应关系.<br>首先我们知道, 在 Spring AOP 中 join point 指代的是所有方法的执行点, 而 point cut 是一个描述信息, 它修饰的是 join point, 通过 point cut, 我们就可以确定哪些 join point 可以被织入 Advice. 对应到我们在上面举的例子, 我们可以做一个简单的类比, join point 就相当于 爪哇的小县城里的百姓, point cut 就相当于 老王所做的指控, 即凶手是个男性, 身高约七尺五寸, 而 advice 则是施加在符合老王所描述的嫌疑人的动作: 抓过来审问.<br>为什么可以这样类比呢?</p>
<p><strong>join point –&gt;</strong> 爪哇的小县城里的百姓: 因为根据定义, join point 是所有可能被织入 advice 的候选的点, 在 Spring AOP中, 则可以认为所有方法执行点都是 join point. 而在我们上面的例子中, 命案发生在小县城中, 按理说在此县城中的所有人都有可能是嫌疑人.</p>
<p><strong>point cut –&gt;</strong>男性, 身高约七尺五寸: 我们知道, 所有的方法(joint point) 都可以织入 advice, 但是我们并不希望在所有方法上都织入 advice, 而 pointcut 的作用就是提供一组规则来匹配joinpoint, 给满足规则的 joinpoint 添加 advice. 同理, 对于县令来说, 他再昏庸, 也知道不能把县城中的所有百姓都抓起来审问, 而是根据凶手是个男性, 身高约七尺五寸, 把符合条件的人抓起来. 在这里 凶手是个男性, 身高约七尺五寸 就是一个修饰谓语, 它限定了凶手的范围, 满足此修饰规则的百姓都是嫌疑人, 都需要抓起来审问.</p>
<p><strong>advice –&gt;</strong> 抓过来审问, advice 是一个动作, 即一段 Java 代码, 这段 Java 代码是作用于 point cut 所限定的那些 join point 上的. 同理, 对比到我们的例子中, 抓过来审问 这个动作就是对作用于那些满足 男性, 身高约七尺五寸 的爪哇的小县城里的百姓.</p>
<p><strong>aspect:</strong> aspect 是 point cut 与 advice 的组合, 因此在这里我们就可以类比: “根据老王的线索, 凡是发现有身高七尺五寸的男性, 都要抓过来审问” <strong>这一整个动作可以被认为是一个 aspect.</strong></p>
<p>整个 aspect 就可以描述为: 满足 pointcut 规则的 joinpoint 会被添加相应的 advice 操作.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://huwj.work/spring/spring-aop" data-id="ck3gl3nt20016vkez3wfbgrq5" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-spring1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/spring/spring1" class="article-date">
  <time datetime="2018-11-17T02:07:02.000Z" itemprop="datePublished">2018-11-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/spring/">spring</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/spring/spring1">spring_DI</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>今天学习到了springmvc 发现了，如果不做好笔记的话，真心容易忘的一干二净。还是把好的东西记下来吧，不能嫌弃麻烦，用的时候看一眼就明白了。</p>
<p>spring 依赖注入的三种方式：</p>
<h2 id="1-自动化配置（最推荐，避免显示配置带来的维护成本）"><a href="#1-自动化配置（最推荐，避免显示配置带来的维护成本）" class="headerlink" title="1 自动化配置（最推荐，避免显示配置带来的维护成本）"></a>1 自动化配置（最推荐，避免显示配置带来的维护成本）</h2><p><strong>（1）组件扫描</strong>：spring自动发现容器所创建的bean。开启组件扫描，默认情况下自动扫描配置类相同包（以及子包）下所有带有@component注解的类，并为其自动创建一个bean。</p>
<pre><code>@ComponentScan(basePackages={&quot;com.seven.springTest.service&quot;,&quot;com.seven.springTest.impl&quot;})</code></pre><p><strong>那么，如何开启组件扫描呢？答：有两种方式，基于java配置(推荐)和xml配置</strong></p>
<p>Java配置：在配置类上添加@componentScan注解</p>
<p>Xml配置：利用&lt;context:component-scan base-package=”…”/&gt;</p>
<p><strong>（2）自动装配</strong>：spring自动满足bean之间的依赖。使用@Autowired（推荐）或@Inject注解添加在构造、setter还是其他方法上，实现bean的自动注入，无需手动去new。</p>
<p><img src="/images/spring/three_di/1.png" alt="Alt text"><br>其中红线为扫描组件，黑线为自动装配。</p>
<h2 id="2-Java配置（推荐，基于java语言，类型安全易于重构）"><a href="#2-Java配置（推荐，基于java语言，类型安全易于重构）" class="headerlink" title="2 Java配置（推荐，基于java语言，类型安全易于重构）"></a>2 Java配置（推荐，基于java语言，类型安全易于重构）</h2><p>利用@Bean注解来声明（创建）一个bean(其实将方式一中的扫描组件以及自动装配方式用@Bean的形式进行取代)，同时还可以注入另外依赖的bean（利用构造器和setter方法）</p>
<pre><code>@Configuration
//@ComponentScan   将启用组件扫描的注解给注释掉，另外需要自己new对象
public class HelloWorldConfig {
    @Bean
    public TVTool tvtool() {
         return new TVTool();
     }
    @Bean
     public IphoneTool iphonetool() {
         return new IphoneTool();
     }
    @Bean//这里是重点，将上面new对象的方法 ，全部以构造器或者是setter的形式传入到其它类中，这里是 PersonHelloWorld类
     public PersonHelloWorld personhelloworld(){
         return new PersonHelloWorld(tvtool(),iphonetool());
     } 
   //下面是构造方法加载bean，说实话，不如直接构造器方便
    @Bean
 public PersonHelloWorld personhelloworld(IphoneTool iphoneTool){
    PersonHelloWorld ll=new PersonHelloWorld(tvtool());
    ll.setIphoneTool(iphoneTool);
    return ll;
 } 
}</code></pre><p>PersonHelloWorld 类中需要有构造方法：</p>
<pre><code>public class PersonHelloWorld implements HelloWorldApi {
    private TVTool tv;
    private IphoneTool iphone;
   public PersonHelloWorld(TVTool tvtool, IphoneTool iphoneTool) {
      this.tv=tvtool;
      this.iphone=iphoneTool;
   }
@Override
    public void sayHello() {
        tv.work();
        iphone.work();
    }
}</code></pre><p><img src="/images/spring/three_di/2.png" alt="Alt text"></p>
<p>其实，这里就是跟传统java的思想很像了，采用@Bean的方式new出java对象，然后使用构造器或者set方式将对象加载到替他的类中。</p>
<h2 id="3-xml配制方法"><a href="#3-xml配制方法" class="headerlink" title="3 xml配制方法"></a>3 xml配制方法</h2><p>xml的方式特别简单了，我最服气的也是这第三种装配方式，没有配置类，直接在web.xml中进行配置各种bean以及初始化数据。<br><img src="/images/spring/three_di/3.png" alt="Alt text"></p>
<pre><code> &lt;bean id=&quot;iphonetool&quot; class=&quot;com.IphoneTool&quot; /&gt;//加载IphoneTool bean
&lt;bean id=&quot;tvtool&quot; class=&quot;com.TvTool&quot; /&gt;//加载TvTool bean
&lt;bean id=&quot;personhelloworld&quot; class=&quot;com.PersonHelloWorld&quot; &gt;//IphoneTool跟TvTool都需要注入到PersonHelloWorld
 &lt;constructor-arg ref=&quot;iphonetool&quot; /&gt;//构造器注入，对应代码如下面
 &lt;property name=&quot;tvTool&quot; ref=&quot;tvtool&quot; /&gt;//seter方式注入，对应代码如下面
 &lt;property name=&quot;artist&quot; value=&quot;xml style&quot; /&gt;//参数注入，代码在下面
&lt;/bean&gt;</code></pre><p>稍微讲解一下，其实就相当于将第二种方式的配置@    Bean模式改为xml进行配置。</p>
<pre><code>&lt;bean id=&quot;iphonetool&quot; class=&quot;com.IphoneTool&quot; /&gt;</code></pre><p>然后通过构造器以及setter等方法进行注入</p>
<pre><code>&lt;constructor-arg ref=&quot;iphonetool&quot; /&gt;//构造器注入</code></pre><p>class后面就是需要加载的bean，前面的id随意，在生成bean之后，就可以通过构造器或者是set方式将bean加载到对应的地方：</p>
<pre><code>public PersonHelloWorld(IphoneTool iphoneTool) {
      this.iphone=iphoneTool;
   }
   public void settvTool(TvTool l) {
       this.tv=l;
   public void setArtist(String artist) {
       this.str=artist;
   }</code></pre><p>*<em>在注入时，名字跟id一定要注意  *</em></p>
<p><img src="/images/spring/three_di/4.png" alt="Alt text"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://huwj.work/spring/spring1" data-id="ck3gl3nt40017vkeze095020v" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-leetcode" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/java/leetcode" class="article-date">
  <time datetime="2018-11-10T01:00:56.000Z" itemprop="datePublished">2018-11-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/java/leetcode">leetcode</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="窗口滑动思想："><a href="#窗口滑动思想：" class="headerlink" title="窗口滑动思想："></a>窗口滑动思想：</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://huwj.work/java/leetcode" data-id="ck3gl3nsh000qvkez0jsz9v6v" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-温馨的话" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/%E7%82%B9%E6%BB%B4%E7%94%9F%E6%B4%BB/%E6%B8%A9%E9%A6%A8%E7%9A%84%E8%AF%9D" class="article-date">
  <time datetime="2018-10-24T09:22:46.000Z" itemprop="datePublished">2018-10-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%82%B9%E6%BB%B4%E7%94%9F%E6%B4%BB/">点滴生活</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/%E7%82%B9%E6%BB%B4%E7%94%9F%E6%B4%BB/%E6%B8%A9%E9%A6%A8%E7%9A%84%E8%AF%9D">sweet</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>问：ta有多少缺点？ </p>
<p>答：像天上星星一样多</p>
<p>问：那优点呢？ </p>
<p>答：像太阳 </p>
<p>问：就只有一个优点了？那你还喜欢他 </p>
<p>答：因为当太阳出现的时候，星星就不见了呀</p>
<p><img src="/images/life/sweet_01.jpg" alt="Alt text"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://huwj.work/%E7%82%B9%E6%BB%B4%E7%94%9F%E6%B4%BB/%E6%B8%A9%E9%A6%A8%E7%9A%84%E8%AF%9D" data-id="ck3gl3nun0028vkez6akv67zk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-时间空间复杂度" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%97%B6%E9%97%B4%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6" class="article-date">
  <time datetime="2018-10-24T07:55:04.000Z" itemprop="datePublished">2018-10-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%97%B6%E9%97%B4%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">时间空间复杂度</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>记笔记是一件很麻烦的事情，但是，在学习一个事物之后，能够以自己的话描述出来，才是真正的理解了。</p>
<p>数据结构的思想就是快和省的问题，现在很多工作过的人，简历能写十几页，经历过得项目有几十个，但是仔细看来，每个项目都是重复地堆彻业务逻辑，没有难度递进，看不出有能力的提升。久而久之，十年的工作还停留在增删改查上面。选了做程序员，就必须接受新的事物，而这个过程就是不断地学习。</p>
<p>其实关于数据结构，对他并非陌生，本科时有过接触，但是并没有深入了解，最骄傲的就属研究生复试考试数据结构答了96分，嗯，从这一点来讲，我还是不错的嘛<del>~</del>嘻嘻。</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度分析</p>
<p>1_只关注循环执行次数最多的一段代码</p>
<p>2_加法法则：总复杂度等于量级最大的那段代码的复杂度</p>
<p>3_乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</p>
<p>常见的复杂度为</p>
<p>O(1) 只要是代码中不出现循环，迭代，即使有很多的代码，他的代码没有出现未知数，也就是说，代码不会随着某一个变量的变化，执行量增加。</p>
<p>对数阶O(logn) 在出现while之后会产生对数阶</p>
<pre><code>i=1;
while (i&lt;= n)  {
  i = i * 2;//这里就是一个对数阶（因为i的值每次增加的为2的倍数，故有2的x次方等于n）这里若
           //i=i*3也是同理
}</code></pre><p>线性阶O(n) 单循环 平方阶O(n*n) 循环嵌套…指数阶O(2的n次方) 阶乘阶O(n!)</p>
<p>特殊的一点：O(m+n)、O(m*n)</p>
<pre><code>int add(int m, int n) {
  int sum_1 = 0;
  int i = 1;
  for (; i &lt; m; ++i) {
    sum_1 = sum_1 + i;
  }

  int sum_2 = 0;
  int j = 1;
  for (; j &lt; n; ++j) {
    sum_2 = sum_2 + j;
  }

  return sum_1 + sum_2;
}</code></pre><p>从代码中可以看出，m 和 n 是表示两个数据级别，无法知道哪一个大，故本程序的复杂度为O(m+n)。但是嵌套后的乘法运算还是可以的。</p>
<pre><code>int add(int m, int n) 
  int sum_1 = 0;
  int i = 1;
  for (; i &lt; m; ++i) {
    sum_1 = sum_1 + i;
    add1();
  }

int add1(){
  int sum_2 = 0;
  int j = 1;
  for (; j &lt; n; ++j) {
    sum_2 = sum_2 + j;
  }
}</code></pre><p>时间复杂度为T1(m)*T2(n) = O(f(m) * f(n))</p>
<p><strong>一、复杂度分析的4个概念</strong></p>
<p>1.最坏情况时间复杂度：代码在最理想情况下执行的时间复杂度。</p>
<p>2.最好情况时间复杂度：代码在最坏情况下执行的时间复杂度。</p>
<p>3.平均时间复杂度：用代码在所有情况下执行的次数的加权平均值表示。</p>
<p>4.均摊时间复杂度：在代码执行的所有复杂度情况中绝大部分是低级别的复杂度，个别情况是高级别复杂度且发生具有时序关系时，可以将个别高级别复杂度均摊到低级别复杂度上。基本上均摊结果就等于低级别复杂度。</p>
<p><strong>二、为什么要引入这4个概念？</strong></p>
<p>1.同一段代码在不同情况下时间复杂度会出现量级差异，为了更全面，更准确的描述代码的时间复杂度，所以引入这4个概念。</p>
<p>2.代码复杂度在不同情况下出现量级差别时才需要区别这四种复杂度。大多数情况下，是不需要区别分析它们的。</p>
<p><strong>三、如何分析平均、均摊时间复杂度？</strong></p>
<p>1.平均时间复杂度</p>
<p>代码在不同情况下复杂度出现量级差别，则用代码所有可能情况下执行次数的加权平均值表示。</p>
<p>2.均摊时间复杂度</p>
<p>两个条件满足时使用：</p>
<p>1）代码在绝大多数情况下是低级别复杂度，只有极少数情况是高级别复杂度；</p>
<p>2）低级别和高级别复杂度出现具有时序规律。</p>
<p><strong>个人体会: 平均和平摊基本就是一个概念，平摊是特殊的平均。在分析时间复杂度是O(1)还是O(n)的时候最简单就是凭感觉…出现O(1)的次数远大于出现O(n)出现的次数，那么平均平摊时间复杂度就是O(1)…</strong></p>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>空间复杂度，一定要明白空间复杂度不是内存占用大小，而是保证程序正常工作时额外需要的内存空间大小，如数组的复制，空间复杂度只为1.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://huwj.work/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%97%B6%E9%97%B4%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6" data-id="ck3gl3nu5001uvkez1vpk15vd" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-stringbuffer" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/java/stringbuffer" class="article-date">
  <time datetime="2018-10-19T07:06:58.000Z" itemprop="datePublished">2018-10-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/java/stringbuffer">stringbuffer</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="stringBuffer-字符串缓冲区"><a href="#stringBuffer-字符串缓冲区" class="headerlink" title="stringBuffer 字符串缓冲区"></a>stringBuffer 字符串缓冲区</h2><p>面盆理论，也就是说，这个缓冲区相当于一个面盆，无论往里面加入什么，或者删除什么，都在这一个面盆（缓冲区）进行。</p>
<pre><code>* stringBuffer 字符串缓冲区
* 用于存储数据的容器
* 特点：（面盆理论）
* 1长度可变
* 2可以存储不同数据类型
* 3最终需要转成字符串才能使用
* 4可以对字符串修改，中间可插入insert（2,&quot;qq&quot;）在2位置插入（从0开始），后面可以append（）
* 
* 既然是一个容器
* 1添加
* 2删除
*  StringBuffer delete(start end)包括头，不包括尾
*     StringBuffer deleteChartAt(index)删除指定位置元素
* 
* 3查找：char charAT(index)
*      int indexOf(string)
*      int lastIndexOf(string)
*  
* 4修改
*         StringBUffer replace（start，end，string）；
*         void setCharAt(index，char)
* 
* 
* </code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://huwj.work/java/stringbuffer" data-id="ck3gl3nth001bvkez310x62z4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-String" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/java/String" class="article-date">
  <time datetime="2018-10-19T02:45:43.000Z" itemprop="datePublished">2018-10-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/java/String">String</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="‘abcd’"><a href="#‘abcd’" class="headerlink" title="‘abcd’"></a>‘abcd’</h3><p><strong>*1获取</strong></p>
<pre><code>*1.1获取字符串当中的字符的个数int length()
*1.2根据位置获取字符
*    char charAt(int index)
*    
* 1.3根据字符获取在字符串中的第一次出现的位置
*    int indexOf(char c)
*      int  indexOf(char c int fromIndex)在指定位置开始对c的查找
*    int indexOf(string str  int fromIndex)在指定位置开始对str的查找
*    
*    从后往前进行查找
*    int lastdexOf(char c)  下角标从0开始算
*      int lastdexOf(char c int fromIndex)在指定位置开始对c的查找
*    int lastdexOf(string str  int fromIndex)在指定位置开始对str的查找
*    
* 1.4获取字符串当中的一部分功能，也叫作子串
*    String substring（int begainindex int endindex）从指定位到endindex位（但是不包括endindex）
*    String substring（int begainindex）下角标从1开始算
*  </code></pre><p><strong>*2 转换</strong></p>
<pre><code>*2.1将字符串转变成字符串数组  （字符串的切割）
*     String[] splite(String regex):涉及到正则表达式
*   2.2将字符串转化为字符数组
*     char[] toCharArray()
*
*   2.2将数组转化为字符串
*private static void stringconstructordemo2() {
*char[] arr= {&apos;a&apos;,&apos;b&apos;,&apos;c&apos;};
*String s1=new String(arr,1,2);
*System.out.println(s1);//输出bc
* }
*
*   2.3将字符串转化为字节数组
*     byte[] getBytes()
*   2.4 将字符串的字幕改为大小写字母
*       String &quot;Abc&quot;.toUpperCase()
*       String &quot;Abc&quot;.toLowerCase()
*   2.5 将字符串的内容进行替换
*      s.replace(&quot;a&quot;,&quot;b&quot;)将字符串s中的a以b代替
*      
*   2.6 s.trim() 去除字符串的两边空格 
*   2.7 s.concat(str)
* </code></pre><p><strong>*3 判断</strong></p>
<pre><code>*3.1两个字符串的内容是否相同
*     s.equalsIgnoreCase(&quot;anotherstring&quot;)//忽略大小写的内容比较
*   3.2字符串当中是否包含另一个String
*     s.contains（&quot;bc&quot;）;
*     或者采用indexOf 若返回-1则没有
*   3.3字符串是否已字符串开头，是否已字符串结尾
* 
* 4比较
*     &quot;abc&quot;.compareTo(&quot;Abc&quot;)
*    
*   
* </code></pre><p><strong>*4 String=”s”跟String s=new String(“s”)</strong> </p>
<pre><code>String s=new String(&quot;s&quot;)并非在常量池中，而是被拆分成char数组进行操作
 String=&quot;s&quot;在常量池中。
public static void main(String[] args) {
 String s1=new String(&quot;abc&quot;);//并非在常量池中，而是被拆分成char数组进行操作
 String s2=s1.intern();//intern（）在常量池中取，若取到，则直接按过来用，若没渠道，则新建一个String对象
 System.out.println(s1==s2);//false
 String s3=&quot;abc&quot;;
 String s4=s3.intern();
 System.out.println(s3==s4);//true
}</code></pre><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code>package cn.itcast.p1string.demo;

public class stringmthod {

public static void main(String[] args) {

    stringMethodDemo_1();
    stringMethodDemo_2();
    stringMethodDemo_3();
    stringMethodDemo_4();
}

private static void stringMethodDemo_4() {
    System.out.println(&quot;abc&quot;.compareTo(&quot;Abc&quot;));//32 其实就是ascii码相减

}

private static void stringMethodDemo_3() {
    String s=&quot;abc&quot;;
    System.out.println(s.equals(&quot;Abc&quot;.toLowerCase()));//true
    System.out.println(s.equalsIgnoreCase(&quot;abC&quot;));//忽略大小写的内容比较  true
    System.out.println(s.contains(&quot;bc&quot;));//r=true

    String Str=&quot;arraydemo.java&quot;;
    System.out.println(Str.startsWith(&quot;array&quot;));//true
    System.out.println(Str.endsWith(&quot;.java&quot;));//true
    System.out.println(Str.contains(&quot;demo&quot;));//true

}

private static void stringMethodDemo_2() {
    String s=&quot;张三,李四,王五&quot;;
    String[] arr=s.split(&quot;,&quot;);
    for (int i=0;i&lt;arr.length;i++)
        System.out.println(arr[i]);//切割成为 张三 李四 王五
    char[] chs=s.toCharArray();
    for (int i=0;i&lt;chs.length;i++)
        System.out.println(chs[i]);//切割成为   张 三 ，李 四 ，王 五
    String s1=&quot;ab你&quot;;
    byte[] bytes=s1.getBytes();
    for (int i=0;i&lt;bytes.length;i++)
        System.out.println(bytes[i]);//97 98 -60 -29   中文的ascii为负数

    System.out.println(&quot;Abc&quot;.toUpperCase());ABC    


}

private static void stringMethodDemo_1() {
    // TODO Auto-generated method stub
    String s=&quot;abcdae&quot;;
    System.out.println(&quot;length:&quot;+s.length());//6
    System.out.println(&quot;cahr&quot;+s.charAt(2));//c
    System.out.println(&quot;index&quot;+s.indexOf(&quot;a&quot;));//0
    System.out.println(&quot;index&quot;+s.indexOf(&quot;k&quot;));//-1代表字符串（字符）没有这个字符，当然在数组中没有找到这个角标也显示-1
    System.out.println(&quot;lastindex&quot;+s.lastIndexOf(&quot;a&quot;));//4
}

}</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://huwj.work/java/String" data-id="ck3gl3nqa0005vkez6mpzepck" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-synchronized" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/java/synchronized" class="article-date">
  <time datetime="2018-10-12T08:25:31.000Z" itemprop="datePublished">2018-10-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/java/synchronized">synchronized</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="线程安全-一定要看一下是否有共享数据"><a href="#线程安全-一定要看一下是否有共享数据" class="headerlink" title="线程安全 一定要看一下是否有共享数据"></a>线程安全 一定要看一下是否有共享数据</h2><p><img src="/images/java/Thread/1.png" alt="Alt text"><br>解决思路，就是将多条操作的<strong>共享数据的线程代码封装起来</strong>，在一个线程进入到代码块的时候，其他线程不可以参与运算，待上一个线程运行完之后，下一个线程才可以进行计算。<br>同步代码块进行封装;（其实就相当于锁的性质，在线程进入到执行代码块过程中，将其进行锁住，其他线程无法进入到代码块中，也就无法对共享资源进行修改）</p>
<p>好处解决了线程安全的问题</p>
<p>坏处 相对降低了效率，因为同步外的线程都会判断同步锁</p>
<pre><code>synchronized(对象) {
需要被同步的代码块；
}</code></pre><p><img src="/images/java/Thread/2.png" alt="Alt text"><br><strong>同步的前提：多个线程并且只是用同一个锁</strong>也就是说，上图的Object对象b一定不能放在run()方法中，因为这样就产生了多个锁，需要将锁放在run（）外面，即上图的情况，只产生一把锁。</p>
<p>小例子：<br><img src="/images/java/Thread/3.png" alt="Alt text"><br>解决述问题：</p>
<pre><code>package socket;
/*
 * 需求：连哥哥储户，每个都到银行存钱，每次100元共3次
*/
class Bank{
private int sum;
Object b=new Object();
public void add(int num) {
    synchronized(b) {
    sum=sum+num;
    try {Thread.sleep(100);}catch(InterruptedException e) {}
    //-----&gt;这里需要强调，如果不是一行代码，如果第一个线程进来，还没来得及输出，下一个线程再次进来将打乱程序，故需要锁机制
    System.out.println(&quot;sun=&quot;+sum);
    }
}
}
class Ticket implements Runnable{

private Bank b=new Bank();
public void run() {
    for (int x=0;x&lt;3;x++) {
        b.add(100);
    }
}

}


public static void main(String[] args) {


    Ticket t=new Ticket();
    Thread t1=new Thread(t);
    Thread t2=new Thread(t);
    t1.start();
    t2.start();
}
}</code></pre><p>另外可以直接将函数作为锁：</p>
<p>直接在函数上加SYNCHRONIZED</p>
<p>上述函数:<code>public synchronized void add（int num）</code><br>关于同步函数的锁这里说一下每个锁都需要一个对象，而同步函数的所得对象就是 <strong>this，故在同步代码块与同步函数一起用的时候，同步代码块中的对象需要使用this</strong></p>
<p>当然，同步函数一定的this 而同步代码块为任意，建议使用同步代码块。<br>但是在static中没有this，它加载的是当前字节码对象，故同步代码块需要this.getClass(),其实说白了，<strong>就是让他们使用同一个锁。</strong>参考毕向东的20课的13节</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://huwj.work/java/synchronized" data-id="ck3gl3ntj001cvkezajq11kir" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/AR/">AR</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/HTML/">HTML</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/book/">book</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/css/">css</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/js/">js</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/office/">office</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/spring/">spring</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/">云计算</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8D%9A%E5%AE%A2/">博客</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%82%B9%E6%BB%B4%E7%94%9F%E6%B4%BB/">点滴生活</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/">神经网络</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/%E7%AE%97%E6%B3%95/%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97%E4%B9%8B%E5%92%8C">最大连续子序列之和</a>
          </li>
        
          <li>
            <a href="/spring/spring-aop-1">spring_aop_代码实现</a>
          </li>
        
          <li>
            <a href="/spring/spring-aop">spring_aop</a>
          </li>
        
          <li>
            <a href="/spring/spring1">spring_DI</a>
          </li>
        
          <li>
            <a href="/java/leetcode">leetcode</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>